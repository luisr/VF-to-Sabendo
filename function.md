[
  {
    "nome_funcao": "_await_response",
    "definicao": "CREATE OR REPLACE FUNCTION net._await_response(request_id bigint)\n RETURNS boolean\n LANGUAGE plpgsql\n PARALLEL SAFE STRICT\nAS $function$\ndeclare\n    rec net._http_response;\nbegin\n    while rec is null loop\n        select *\n        into rec\n        from net._http_response\n        where id = request_id;\n\n        if rec is null then\n            -- Wait 50 ms before checking again\n            perform pg_sleep(0.05);\n        end if;\n    end loop;\n\n    return true;\nend;\n$function$\n"
  },
  {
    "nome_funcao": "_crypto_aead_det_decrypt",
    "definicao": "CREATE OR REPLACE FUNCTION vault._crypto_aead_det_decrypt(message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_decrypt_by_id$function$\n"
  },
  {
    "nome_funcao": "_crypto_aead_det_encrypt",
    "definicao": "CREATE OR REPLACE FUNCTION vault._crypto_aead_det_encrypt(message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_encrypt_by_id$function$\n"
  },
  {
    "nome_funcao": "_crypto_aead_det_noncegen",
    "definicao": "CREATE OR REPLACE FUNCTION vault._crypto_aead_det_noncegen()\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_noncegen$function$\n"
  },
  {
    "nome_funcao": "_encode_url_with_params_array",
    "definicao": "CREATE OR REPLACE FUNCTION net._encode_url_with_params_array(url text, params_array text[])\n RETURNS text\n LANGUAGE c\n IMMUTABLE STRICT\nAS 'pg_net', $function$_encode_url_with_params_array$function$\n"
  },
  {
    "nome_funcao": "_http_collect_response",
    "definicao": "CREATE OR REPLACE FUNCTION net._http_collect_response(request_id bigint, async boolean DEFAULT true)\n RETURNS net.http_response_result\n LANGUAGE plpgsql\n PARALLEL SAFE STRICT\nAS $function$\ndeclare\n    rec net._http_response;\n    req_exists boolean;\nbegin\n\n    if not async then\n        perform net._await_response(request_id);\n    end if;\n\n    select *\n    into rec\n    from net._http_response\n    where id = request_id;\n\n    if rec is null or rec.error_msg is not null then\n        -- The request is either still processing or the request_id provided does not exist\n\n        -- TODO: request in progress is indistinguishable from request that doesn't exist\n\n        -- No request matching request_id found\n        return (\n            'ERROR',\n            coalesce(rec.error_msg, 'request matching request_id not found'),\n            null\n        )::net.http_response_result;\n\n    end if;\n\n    -- Return a valid, populated http_response_result\n    return (\n        'SUCCESS',\n        'ok',\n        (\n            rec.status_code,\n            rec.headers,\n            rec.content\n        )::net.http_response\n    )::net.http_response_result;\nend;\n$function$\n"
  },
  {
    "nome_funcao": "_internal_resolve",
    "definicao": "CREATE OR REPLACE FUNCTION graphql._internal_resolve(query text, variables jsonb DEFAULT '{}'::jsonb, \"operationName\" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE c\nAS '$libdir/pg_graphql', $function$resolve_wrapper$function$\n"
  },
  {
    "nome_funcao": "_urlencode_string",
    "definicao": "CREATE OR REPLACE FUNCTION net._urlencode_string(string character varying)\n RETURNS text\n LANGUAGE c\n IMMUTABLE STRICT\nAS 'pg_net', $function$_urlencode_string$function$\n"
  },
  {
    "nome_funcao": "add_prefixes",
    "definicao": "CREATE OR REPLACE FUNCTION storage.add_prefixes(_bucket_id text, _name text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    prefixes text[];\nBEGIN\n    prefixes := \"storage\".\"get_prefixes\"(\"_name\");\n\n    IF array_length(prefixes, 1) > 0 THEN\n        INSERT INTO storage.prefixes (name, bucket_id)\n        SELECT UNNEST(prefixes) as name, \"_bucket_id\" ON CONFLICT DO NOTHING;\n    END IF;\nEND;\n$function$\n"
  },
  {
    "nome_funcao": "add_task_observation",
    "definicao": "CREATE OR REPLACE FUNCTION public.add_task_observation(p_task_id uuid, p_content text, p_attachment_url text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_project_id uuid;\r\n    new_observation_id uuid;\r\n    new_observation_data jsonb;\r\nBEGIN\r\n    SELECT project_id INTO v_project_id FROM public.tasks WHERE public.tasks.id = p_task_id;\r\n    IF NOT is_project_member(v_project_id, auth.uid()) THEN\r\n        RAISE EXCEPTION 'Acesso não autorizado.';\r\n    END IF;\r\n\r\n    INSERT INTO public.task_observations (task_id, author_id, content, attachment_url)\r\n    VALUES (p_task_id, auth.uid(), p_content, p_attachment_url)\r\n    RETURNING public.task_observations.id INTO new_observation_id;\r\n\r\n    SELECT jsonb_build_object(\r\n        'id', o.id, 'author', jsonb_build_object('id', u.id, 'name', u.name)\r\n        -- ... (outros campos)\r\n    )\r\n    INTO new_observation_data\r\n    FROM public.task_observations o\r\n    LEFT JOIN public.profiles u ON o.author_id = u.id\r\n    WHERE o.id = new_observation_id;\r\n\r\n    RETURN new_observation_data;\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "apply_rls",
    "definicao": "CREATE OR REPLACE FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer DEFAULT (1024 * 1024))\n RETURNS SETOF realtime.wal_rls\n LANGUAGE plpgsql\nAS $function$\ndeclare\n-- Regclass of the table e.g. public.notes\nentity_ regclass = (quote_ident(wal ->> 'schema') || '.' || quote_ident(wal ->> 'table'))::regclass;\n\n-- I, U, D, T: insert, update ...\naction realtime.action = (\n    case wal ->> 'action'\n        when 'I' then 'INSERT'\n        when 'U' then 'UPDATE'\n        when 'D' then 'DELETE'\n        else 'ERROR'\n    end\n);\n\n-- Is row level security enabled for the table\nis_rls_enabled bool = relrowsecurity from pg_class where oid = entity_;\n\nsubscriptions realtime.subscription[] = array_agg(subs)\n    from\n        realtime.subscription subs\n    where\n        subs.entity = entity_;\n\n-- Subscription vars\nroles regrole[] = array_agg(distinct us.claims_role::text)\n    from\n        unnest(subscriptions) us;\n\nworking_role regrole;\nclaimed_role regrole;\nclaims jsonb;\n\nsubscription_id uuid;\nsubscription_has_access bool;\nvisible_to_subscription_ids uuid[] = '{}';\n\n-- structured info for wal's columns\ncolumns realtime.wal_column[];\n-- previous identity values for update/delete\nold_columns realtime.wal_column[];\n\nerror_record_exceeds_max_size boolean = octet_length(wal::text) > max_record_bytes;\n\n-- Primary jsonb output for record\noutput jsonb;\n\nbegin\nperform set_config('role', null, true);\n\ncolumns =\n    array_agg(\n        (\n            x->>'name',\n            x->>'type',\n            x->>'typeoid',\n            realtime.cast(\n                (x->'value') #>> '{}',\n                coalesce(\n                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4\n                    (x->>'type')::regtype\n                )\n            ),\n            (pks ->> 'name') is not null,\n            true\n        )::realtime.wal_column\n    )\n    from\n        jsonb_array_elements(wal -> 'columns') x\n        left join jsonb_array_elements(wal -> 'pk') pks\n            on (x ->> 'name') = (pks ->> 'name');\n\nold_columns =\n    array_agg(\n        (\n            x->>'name',\n            x->>'type',\n            x->>'typeoid',\n            realtime.cast(\n                (x->'value') #>> '{}',\n                coalesce(\n                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4\n                    (x->>'type')::regtype\n                )\n            ),\n            (pks ->> 'name') is not null,\n            true\n        )::realtime.wal_column\n    )\n    from\n        jsonb_array_elements(wal -> 'identity') x\n        left join jsonb_array_elements(wal -> 'pk') pks\n            on (x ->> 'name') = (pks ->> 'name');\n\nfor working_role in select * from unnest(roles) loop\n\n    -- Update `is_selectable` for columns and old_columns\n    columns =\n        array_agg(\n            (\n                c.name,\n                c.type_name,\n                c.type_oid,\n                c.value,\n                c.is_pkey,\n                pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')\n            )::realtime.wal_column\n        )\n        from\n            unnest(columns) c;\n\n    old_columns =\n            array_agg(\n                (\n                    c.name,\n                    c.type_name,\n                    c.type_oid,\n                    c.value,\n                    c.is_pkey,\n                    pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')\n                )::realtime.wal_column\n            )\n            from\n                unnest(old_columns) c;\n\n    if action <> 'DELETE' and count(1) = 0 from unnest(columns) c where c.is_pkey then\n        return next (\n            jsonb_build_object(\n                'schema', wal ->> 'schema',\n                'table', wal ->> 'table',\n                'type', action\n            ),\n            is_rls_enabled,\n            -- subscriptions is already filtered by entity\n            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),\n            array['Error 400: Bad Request, no primary key']\n        )::realtime.wal_rls;\n\n    -- The claims role does not have SELECT permission to the primary key of entity\n    elsif action <> 'DELETE' and sum(c.is_selectable::int) <> count(1) from unnest(columns) c where c.is_pkey then\n        return next (\n            jsonb_build_object(\n                'schema', wal ->> 'schema',\n                'table', wal ->> 'table',\n                'type', action\n            ),\n            is_rls_enabled,\n            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),\n            array['Error 401: Unauthorized']\n        )::realtime.wal_rls;\n\n    else\n        output = jsonb_build_object(\n            'schema', wal ->> 'schema',\n            'table', wal ->> 'table',\n            'type', action,\n            'commit_timestamp', to_char(\n                ((wal ->> 'timestamp')::timestamptz at time zone 'utc'),\n                'YYYY-MM-DD\"T\"HH24:MI:SS.MS\"Z\"'\n            ),\n            'columns', (\n                select\n                    jsonb_agg(\n                        jsonb_build_object(\n                            'name', pa.attname,\n                            'type', pt.typname\n                        )\n                        order by pa.attnum asc\n                    )\n                from\n                    pg_attribute pa\n                    join pg_type pt\n                        on pa.atttypid = pt.oid\n                where\n                    attrelid = entity_\n                    and attnum > 0\n                    and pg_catalog.has_column_privilege(working_role, entity_, pa.attname, 'SELECT')\n            )\n        )\n        -- Add \"record\" key for insert and update\n        || case\n            when action in ('INSERT', 'UPDATE') then\n                jsonb_build_object(\n                    'record',\n                    (\n                        select\n                            jsonb_object_agg(\n                                -- if unchanged toast, get column name and value from old record\n                                coalesce((c).name, (oc).name),\n                                case\n                                    when (c).name is null then (oc).value\n                                    else (c).value\n                                end\n                            )\n                        from\n                            unnest(columns) c\n                            full outer join unnest(old_columns) oc\n                                on (c).name = (oc).name\n                        where\n                            coalesce((c).is_selectable, (oc).is_selectable)\n                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                    )\n                )\n            else '{}'::jsonb\n        end\n        -- Add \"old_record\" key for update and delete\n        || case\n            when action = 'UPDATE' then\n                jsonb_build_object(\n                        'old_record',\n                        (\n                            select jsonb_object_agg((c).name, (c).value)\n                            from unnest(old_columns) c\n                            where\n                                (c).is_selectable\n                                and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                        )\n                    )\n            when action = 'DELETE' then\n                jsonb_build_object(\n                    'old_record',\n                    (\n                        select jsonb_object_agg((c).name, (c).value)\n                        from unnest(old_columns) c\n                        where\n                            (c).is_selectable\n                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                            and ( not is_rls_enabled or (c).is_pkey ) -- if RLS enabled, we can't secure deletes so filter to pkey\n                    )\n                )\n            else '{}'::jsonb\n        end;\n\n        -- Create the prepared statement\n        if is_rls_enabled and action <> 'DELETE' then\n            if (select 1 from pg_prepared_statements where name = 'walrus_rls_stmt' limit 1) > 0 then\n                deallocate walrus_rls_stmt;\n            end if;\n            execute realtime.build_prepared_statement_sql('walrus_rls_stmt', entity_, columns);\n        end if;\n\n        visible_to_subscription_ids = '{}';\n\n        for subscription_id, claims in (\n                select\n                    subs.subscription_id,\n                    subs.claims\n                from\n                    unnest(subscriptions) subs\n                where\n                    subs.entity = entity_\n                    and subs.claims_role = working_role\n                    and (\n                        realtime.is_visible_through_filters(columns, subs.filters)\n                        or (\n                          action = 'DELETE'\n                          and realtime.is_visible_through_filters(old_columns, subs.filters)\n                        )\n                    )\n        ) loop\n\n            if not is_rls_enabled or action = 'DELETE' then\n                visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;\n            else\n                -- Check if RLS allows the role to see the record\n                perform\n                    -- Trim leading and trailing quotes from working_role because set_config\n                    -- doesn't recognize the role as valid if they are included\n                    set_config('role', trim(both '\"' from working_role::text), true),\n                    set_config('request.jwt.claims', claims::text, true);\n\n                execute 'execute walrus_rls_stmt' into subscription_has_access;\n\n                if subscription_has_access then\n                    visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;\n                end if;\n            end if;\n        end loop;\n\n        perform set_config('role', null, true);\n\n        return next (\n            output,\n            is_rls_enabled,\n            visible_to_subscription_ids,\n            case\n                when error_record_exceeds_max_size then array['Error 413: Payload Too Large']\n                else '{}'\n            end\n        )::realtime.wal_rls;\n\n    end if;\nend loop;\n\nperform set_config('role', null, true);\nend;\n$function$\n"
  },
  {
    "nome_funcao": "armor",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.armor(bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_armor$function$\n"
  },
  {
    "nome_funcao": "armor",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.armor(bytea, text[], text[])\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_armor$function$\n"
  },
  {
    "nome_funcao": "broadcast_changes",
    "definicao": "CREATE OR REPLACE FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text DEFAULT 'ROW'::text)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    -- Declare a variable to hold the JSONB representation of the row\n    row_data jsonb := '{}'::jsonb;\nBEGIN\n    IF level = 'STATEMENT' THEN\n        RAISE EXCEPTION 'function can only be triggered for each row, not for each statement';\n    END IF;\n    -- Check the operation type and handle accordingly\n    IF operation = 'INSERT' OR operation = 'UPDATE' OR operation = 'DELETE' THEN\n        row_data := jsonb_build_object('old_record', OLD, 'record', NEW, 'operation', operation, 'table', table_name, 'schema', table_schema);\n        PERFORM realtime.send (row_data, event_name, topic_name);\n    ELSE\n        RAISE EXCEPTION 'Unexpected operation type: %', operation;\n    END IF;\nEXCEPTION\n    WHEN OTHERS THEN\n        RAISE EXCEPTION 'Failed to process the row: %', SQLERRM;\nEND;\n\n$function$\n"
  },
  {
    "nome_funcao": "build_prepared_statement_sql",
    "definicao": "CREATE OR REPLACE FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[])\n RETURNS text\n LANGUAGE sql\nAS $function$\n      /*\n      Builds a sql string that, if executed, creates a prepared statement to\n      tests retrive a row from *entity* by its primary key columns.\n      Example\n          select realtime.build_prepared_statement_sql('public.notes', '{\"id\"}'::text[], '{\"bigint\"}'::text[])\n      */\n          select\n      'prepare ' || prepared_statement_name || ' as\n          select\n              exists(\n                  select\n                      1\n                  from\n                      ' || entity || '\n                  where\n                      ' || string_agg(quote_ident(pkc.name) || '=' || quote_nullable(pkc.value #>> '{}') , ' and ') || '\n              )'\n          from\n              unnest(columns) pkc\n          where\n              pkc.is_pkey\n          group by\n              entity\n      $function$\n"
  },
  {
    "nome_funcao": "bytea_to_text",
    "definicao": "CREATE OR REPLACE FUNCTION public.bytea_to_text(data bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE STRICT\nAS '$libdir/http', $function$bytea_to_text$function$\n"
  },
  {
    "nome_funcao": "can_access_task_data",
    "definicao": "CREATE OR REPLACE FUNCTION public.can_access_task_data(p_task_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_project_id uuid;\r\nBEGIN\r\n    SELECT project_id INTO v_project_id FROM public.tasks WHERE id = p_task_id;\r\n    RETURN is_project_member(v_project_id, auth.uid());\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "can_insert_object",
    "definicao": "CREATE OR REPLACE FUNCTION storage.can_insert_object(bucketid text, name text, owner uuid, metadata jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  INSERT INTO \"storage\".\"objects\" (\"bucket_id\", \"name\", \"owner\", \"metadata\") VALUES (bucketid, name, owner, metadata);\n  -- hack to rollback the successful insert\n  RAISE sqlstate 'PT200' using\n  message = 'ROLLBACK',\n  detail = 'rollback successful insert';\nEND\n$function$\n"
  },
  {
    "nome_funcao": "cast",
    "definicao": "CREATE OR REPLACE FUNCTION realtime.\"cast\"(val text, type_ regtype)\n RETURNS jsonb\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\n    declare\n      res jsonb;\n    begin\n      execute format('select to_jsonb(%L::'|| type_::text || ')', val)  into res;\n      return res;\n    end\n    $function$\n"
  },
  {
    "nome_funcao": "check_equality_op",
    "definicao": "CREATE OR REPLACE FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text)\n RETURNS boolean\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\n      /*\n      Casts *val_1* and *val_2* as type *type_* and check the *op* condition for truthiness\n      */\n      declare\n          op_symbol text = (\n              case\n                  when op = 'eq' then '='\n                  when op = 'neq' then '!='\n                  when op = 'lt' then '<'\n                  when op = 'lte' then '<='\n                  when op = 'gt' then '>'\n                  when op = 'gte' then '>='\n                  when op = 'in' then '= any'\n                  else 'UNKNOWN OP'\n              end\n          );\n          res boolean;\n      begin\n          execute format(\n              'select %L::'|| type_::text || ' ' || op_symbol\n              || ' ( %L::'\n              || (\n                  case\n                      when op = 'in' then type_::text || '[]'\n                      else type_::text end\n              )\n              || ')', val_1, val_2) into res;\n          return res;\n      end;\n      $function$\n"
  },
  {
    "nome_funcao": "check_worker_is_up",
    "definicao": "CREATE OR REPLACE FUNCTION net.check_worker_is_up()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nbegin\n  if not exists (select pid from pg_stat_activity where backend_type ilike '%pg_net%') then\n    raise exception using\n      message = 'the pg_net background worker is not up'\n    , detail  = 'the pg_net background worker is down due to an internal error and cannot process requests'\n    , hint    = 'make sure that you didn''t modify any of pg_net internal tables';\n  end if;\nend\n$function$\n"
  },
  {
    "nome_funcao": "comment_directive",
    "definicao": "CREATE OR REPLACE FUNCTION graphql.comment_directive(comment_ text)\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n    /*\n    comment on column public.account.name is '@graphql.name: myField'\n    */\n    select\n        coalesce(\n            (\n                regexp_match(\n                    comment_,\n                    '@graphql\\((.+)\\)'\n                )\n            )[1]::jsonb,\n            jsonb_build_object()\n        )\n$function$\n"
  },
  {
    "nome_funcao": "create_project_baseline",
    "definicao": "CREATE OR REPLACE FUNCTION public.create_project_baseline(p_project_id uuid, p_baseline_name text)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_baseline_id uuid;\r\nBEGIN\r\n    -- 1. Verifica a permissão.\r\n    IF NOT is_project_member(p_project_id, auth.uid()) THEN\r\n        RAISE EXCEPTION 'Acesso não autorizado.';\r\n    END IF;\r\n\r\n    -- 2. Cria a entrada principal da linha de base.\r\n    INSERT INTO public.project_baselines (project_id, name)\r\n    VALUES (p_project_id, p_baseline_name)\r\n    RETURNING id INTO v_baseline_id;\r\n\r\n    -- 3. Copia as datas de todas as tarefas do projeto para a tabela de snapshots.\r\n    --    Usa COALESCE para definir uma data padrão se as datas forem nulas.\r\n    INSERT INTO public.task_baselines (baseline_id, task_id, start_date, end_date)\r\n    SELECT\r\n        v_baseline_id,\r\n        t.id,\r\n        COALESCE(t.start_date, CURRENT_DATE),\r\n        COALESCE(t.end_date, CURRENT_DATE)\r\n    FROM public.tasks t\r\n    WHERE t.project_id = p_project_id;\r\n\r\n    RETURN v_baseline_id;\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "create_secret",
    "definicao": "CREATE OR REPLACE FUNCTION vault.create_secret(new_secret text, new_name text DEFAULT NULL::text, new_description text DEFAULT ''::text, new_key_id uuid DEFAULT NULL::uuid)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  rec record;\nBEGIN\n  INSERT INTO vault.secrets (secret, name, description)\n  VALUES (\n    new_secret,\n    new_name,\n    new_description\n  )\n  RETURNING * INTO rec;\n  UPDATE vault.secrets s\n  SET secret = encode(vault._crypto_aead_det_encrypt(\n    message := convert_to(rec.secret, 'utf8'),\n    additional := convert_to(s.id::text, 'utf8'),\n    key_id := 0,\n    context := 'pgsodium'::bytea,\n    nonce := rec.nonce\n  ), 'base64')\n  WHERE id = rec.id;\n  RETURN rec.id;\nEND\n$function$\n"
  },
  {
    "nome_funcao": "crypt",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.crypt(text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_crypt$function$\n"
  },
  {
    "nome_funcao": "dearmor",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.dearmor(text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_dearmor$function$\n"
  },
  {
    "nome_funcao": "decrypt",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.decrypt(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_decrypt$function$\n"
  },
  {
    "nome_funcao": "decrypt_iv",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.decrypt_iv(bytea, bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_decrypt_iv$function$\n"
  },
  {
    "nome_funcao": "delete_prefix",
    "definicao": "CREATE OR REPLACE FUNCTION storage.delete_prefix(_bucket_id text, _name text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Check if we can delete the prefix\n    IF EXISTS(\n        SELECT FROM \"storage\".\"prefixes\"\n        WHERE \"prefixes\".\"bucket_id\" = \"_bucket_id\"\n          AND level = \"storage\".\"get_level\"(\"_name\") + 1\n          AND \"prefixes\".\"name\" COLLATE \"C\" LIKE \"_name\" || '/%'\n        LIMIT 1\n    )\n    OR EXISTS(\n        SELECT FROM \"storage\".\"objects\"\n        WHERE \"objects\".\"bucket_id\" = \"_bucket_id\"\n          AND \"storage\".\"get_level\"(\"objects\".\"name\") = \"storage\".\"get_level\"(\"_name\") + 1\n          AND \"objects\".\"name\" COLLATE \"C\" LIKE \"_name\" || '/%'\n        LIMIT 1\n    ) THEN\n    -- There are sub-objects, skip deletion\n    RETURN false;\n    ELSE\n        DELETE FROM \"storage\".\"prefixes\"\n        WHERE \"prefixes\".\"bucket_id\" = \"_bucket_id\"\n          AND level = \"storage\".\"get_level\"(\"_name\")\n          AND \"prefixes\".\"name\" = \"_name\";\n        RETURN true;\n    END IF;\nEND;\n$function$\n"
  },
  {
    "nome_funcao": "delete_prefix_hierarchy_trigger",
    "definicao": "CREATE OR REPLACE FUNCTION storage.delete_prefix_hierarchy_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    prefix text;\nBEGIN\n    prefix := \"storage\".\"get_prefix\"(OLD.\"name\");\n\n    IF coalesce(prefix, '') != '' THEN\n        PERFORM \"storage\".\"delete_prefix\"(OLD.\"bucket_id\", prefix);\n    END IF;\n\n    RETURN OLD;\nEND;\n$function$\n"
  },
  {
    "nome_funcao": "delete_project",
    "definicao": "CREATE OR REPLACE FUNCTION public.delete_project(p_project_id uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  v_user_id uuid := auth.uid();\r\n  v_can_delete boolean;\r\nBEGIN\r\n  -- 1. Verifica se o usuário é o proprietário ou gerente do projeto\r\n  SELECT is_project_manager(p_project_id, v_user_id) INTO v_can_delete;\r\n\r\n  IF v_can_delete IS NULL OR NOT v_can_delete THEN\r\n    RETURN jsonb_build_object('success', false, 'message', 'Apenas o proprietário ou gerentes podem excluir o projeto.');\r\n  END IF;\r\n\r\n  -- 2. Deleta o projeto da tabela 'projects'\r\n  -- Graças ao `ON DELETE CASCADE`, todos os dados relacionados serão excluídos.\r\n  DELETE FROM projects WHERE id = p_project_id;\r\n\r\n  -- 3. Retorna uma resposta de sucesso\r\n  RETURN jsonb_build_object(\r\n    'success', true, \r\n    'message', 'Projeto e todos os seus dados associados foram excluídos.'\r\n  );\r\nEXCEPTION\r\n  WHEN OTHERS THEN\r\n    -- Em caso de erro, retorna uma resposta de falha\r\n    RETURN jsonb_build_object('success', false, 'message', 'Ocorreu um erro ao excluir o projeto: ' || SQLERRM);\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "delete_project_baseline",
    "definicao": "CREATE OR REPLACE FUNCTION public.delete_project_baseline(p_baseline_id uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_project_id uuid;\r\nBEGIN\r\n    -- 1. Primeiro, encontra o ID do projeto a que a linha de base pertence.\r\n    SELECT project_id INTO v_project_id FROM public.project_baselines WHERE id = p_baseline_id;\r\n\r\n    -- 2. Se a linha de base não for encontrada, lança um erro.\r\n    IF v_project_id IS NULL THEN\r\n        RAISE EXCEPTION 'Linha de base não encontrada.';\r\n    END IF;\r\n    \r\n    -- 3. Verifica se o usuário tem permissão para apagar (é membro do projeto).\r\n    IF NOT is_project_member(v_project_id, auth.uid()) THEN\r\n        RAISE EXCEPTION 'Acesso não autorizado: Você não pode apagar linhas de base para este projeto.';\r\n    END IF;\r\n\r\n    -- 4. Apaga a linha de base. A constraint ON DELETE CASCADE nas tabelas\r\n    --    garante que todos os snapshots de tarefas em `task_baselines`\r\n    --    sejam apagados automaticamente.\r\n    DELETE FROM public.project_baselines WHERE id = p_baseline_id;\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "delete_task",
    "definicao": "CREATE OR REPLACE FUNCTION public.delete_task(p_task_id uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_user_id uuid := auth.uid();\r\n    v_project_id uuid;\r\nBEGIN\r\n    -- Obter o ID do projeto da tarefa para verificar a associação\r\n    SELECT project_id INTO v_project_id FROM tasks WHERE id = p_task_id;\r\n\r\n    -- Se a tarefa não for encontrada, retorna erro\r\n    IF v_project_id IS NULL THEN\r\n        RETURN jsonb_build_object('success', false, 'message', 'Tarefa não encontrada.');\r\n    END IF;\r\n\r\n    -- CORREÇÃO: A ordem dos parâmetros na chamada de is_project_member foi corrigida.\r\n    -- A ordem correta é (project_id, user_id).\r\n    IF NOT is_project_member(v_project_id, v_user_id) THEN\r\n        RETURN jsonb_build_object('success', false, 'message', 'Você não tem permissão para excluir tarefas neste projeto.');\r\n    END IF;\r\n\r\n    -- Deletar a tarefa\r\n    DELETE FROM tasks WHERE id = p_task_id;\r\n\r\n    -- Retornar sucesso\r\n    RETURN jsonb_build_object('success', true, 'message', 'Tarefa excluída com sucesso.');\r\n\r\nEXCEPTION\r\n    WHEN OTHERS THEN\r\n        RETURN jsonb_build_object('success', false, 'message', 'Erro ao excluir a tarefa: ' || SQLERRM);\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "delete_task_observation",
    "definicao": "CREATE OR REPLACE FUNCTION public.delete_task_observation(p_observation_id uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_project_id uuid;\r\n    v_author_id uuid;\r\nBEGIN\r\n    -- Usa uma sub-consulta para obter o project_id, evitando o JOIN direto.\r\n    SELECT (SELECT project_id FROM public.tasks WHERE id = o.task_id), o.author_id\r\n    INTO v_project_id, v_author_id\r\n    FROM public.task_observations o\r\n    WHERE o.id = p_observation_id;\r\n\r\n    IF v_project_id IS NULL THEN\r\n        RAISE EXCEPTION 'Observação não encontrada.';\r\n    END IF;\r\n\r\n    IF v_author_id = auth.uid() OR is_project_member(v_project_id, auth.uid()) THEN\r\n        DELETE FROM public.task_observations WHERE id = p_observation_id;\r\n    ELSE\r\n        RAISE EXCEPTION 'Acesso não autorizado.';\r\n    END IF;\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "digest",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.digest(bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_digest$function$\n"
  },
  {
    "nome_funcao": "digest",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.digest(text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_digest$function$\n"
  },
  {
    "nome_funcao": "email",
    "definicao": "CREATE OR REPLACE FUNCTION auth.email()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.email', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email')\n  )::text\n$function$\n"
  },
  {
    "nome_funcao": "encrypt",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.encrypt(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_encrypt$function$\n"
  },
  {
    "nome_funcao": "encrypt_iv",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.encrypt_iv(bytea, bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_encrypt_iv$function$\n"
  },
  {
    "nome_funcao": "enforce_bucket_name_length",
    "definicao": "CREATE OR REPLACE FUNCTION storage.enforce_bucket_name_length()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nbegin\n    if length(new.name) > 100 then\n        raise exception 'bucket name \"%\" is too long (% characters). Max is 100.', new.name, length(new.name);\n    end if;\n    return new;\nend;\n$function$\n"
  },
  {
    "nome_funcao": "exception",
    "definicao": "CREATE OR REPLACE FUNCTION graphql.exception(message text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nbegin\n    raise exception using errcode='22000', message=message;\nend;\n$function$\n"
  },
  {
    "nome_funcao": "extension",
    "definicao": "CREATE OR REPLACE FUNCTION storage.extension(name text)\n RETURNS text\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\nDECLARE\n    _parts text[];\n    _filename text;\nBEGIN\n    SELECT string_to_array(name, '/') INTO _parts;\n    SELECT _parts[array_length(_parts,1)] INTO _filename;\n    RETURN reverse(split_part(reverse(_filename), '.', 1));\nEND\n$function$\n"
  },
  {
    "nome_funcao": "filename",
    "definicao": "CREATE OR REPLACE FUNCTION storage.filename(name text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n_parts text[];\nBEGIN\n\tselect string_to_array(name, '/') into _parts;\n\treturn _parts[array_length(_parts,1)];\nEND\n$function$\n"
  },
  {
    "nome_funcao": "foldername",
    "definicao": "CREATE OR REPLACE FUNCTION storage.foldername(name text)\n RETURNS text[]\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\nDECLARE\n    _parts text[];\nBEGIN\n    -- Split on \"/\" to get path segments\n    SELECT string_to_array(name, '/') INTO _parts;\n    -- Return everything except the last segment\n    RETURN _parts[1 : array_length(_parts,1) - 1];\nEND\n$function$\n"
  },
  {
    "nome_funcao": "gen_random_bytes",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.gen_random_bytes(integer)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_random_bytes$function$\n"
  },
  {
    "nome_funcao": "gen_random_uuid",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.gen_random_uuid()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE\nAS '$libdir/pgcrypto', $function$pg_random_uuid$function$\n"
  },
  {
    "nome_funcao": "gen_salt",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.gen_salt(text)\n RETURNS text\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_gen_salt$function$\n"
  },
  {
    "nome_funcao": "gen_salt",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.gen_salt(text, integer)\n RETURNS text\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_gen_salt_rounds$function$\n"
  },
  {
    "nome_funcao": "get_all_user_tasks",
    "definicao": "CREATE OR REPLACE FUNCTION public.get_all_user_tasks()\n RETURNS TABLE(id uuid, formatted_id text, name text, description text, assignee_id uuid, status_id uuid, priority text, start_date date, end_date date, progress integer, parent_id uuid, is_milestone boolean, created_at timestamp with time zone, project_id uuid, project_name text, assignee_name text, status_name text, status_color text, tags json, custom_fields jsonb, dependency_ids uuid[])\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    SELECT\r\n        t.id, 'TSK-' || lpad(t.task_serial_id::text, 4, '0'), t.name, t.description, t.assignee_id,\r\n        t.status_id, t.priority::text, t.start_date, t.end_date, t.progress, t.parent_id,\r\n        t.is_milestone, t.created_at, t.project_id, p.name as project_name,\r\n        -- CORREÇÃO: Usa COALESCE para usar o email se o nome for nulo.\r\n        COALESCE(prof.name, prof.email) as assignee_name,\r\n        ts.name as status_name, ts.color as status_color,\r\n        (SELECT json_agg(json_build_object('id', tg.id, 'name', tg.name, 'color', tg.color)) FROM public.task_tags tt JOIN public.tags tg ON tt.tag_id = tg.id WHERE tt.task_id = t.id) as tags,\r\n        t.custom_fields,\r\n        ARRAY(SELECT td.dependency_id FROM public.task_dependencies td WHERE td.task_id = t.id)\r\n    FROM public.tasks t\r\n    LEFT JOIN public.projects p ON t.project_id = p.id\r\n    LEFT JOIN public.profiles prof ON t.assignee_id = prof.id\r\n    LEFT JOIN public.task_statuses ts ON t.status_id = ts.id\r\n    WHERE is_project_member(t.project_id, auth.uid());\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "get_all_users",
    "definicao": "CREATE OR REPLACE FUNCTION public.get_all_users()\n RETURNS SETOF profiles\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$ BEGIN RETURN QUERY SELECT * FROM public.profiles; END; $function$\n"
  },
  {
    "nome_funcao": "get_auth",
    "definicao": "CREATE OR REPLACE FUNCTION pgbouncer.get_auth(p_usename text)\n RETURNS TABLE(username text, password text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nbegin\n    raise debug 'PgBouncer auth request: %', p_usename;\n\n    return query\n    select \n        rolname::text, \n        case when rolvaliduntil < now() \n            then null \n            else rolpassword::text \n        end \n    from pg_authid \n    where rolname=$1 and rolcanlogin;\nend;\n$function$\n"
  },
  {
    "nome_funcao": "get_bi_data",
    "definicao": "CREATE OR REPLACE FUNCTION public.get_bi_data(p_project_id uuid)\n RETURNS TABLE(task_id uuid, task_name text, changed_at timestamp with time zone, changed_field text, old_value text, new_value text)\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    SELECT\r\n        th.task_id,\r\n        t.name as task_name,\r\n        th.changed_at,\r\n        th.changed_field,\r\n        th.old_value,\r\n        th.new_value\r\n    FROM public.task_history th\r\n    JOIN public.tasks t ON th.task_id = t.id\r\n    WHERE t.project_id = p_project_id\r\n      AND (\r\n          EXISTS (SELECT 1 FROM public.projects p WHERE p.id = t.project_id AND p.owner_id = auth.uid()) OR\r\n          EXISTS (SELECT 1 FROM public.collaborators c WHERE c.project_id = t.project_id AND c.user_id = auth.uid())\r\n      )\r\n    ORDER BY th.changed_at DESC;\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "get_dashboard_page_data",
    "definicao": "CREATE OR REPLACE FUNCTION public.get_dashboard_page_data(p_project_id uuid DEFAULT NULL::uuid, p_manager_id uuid DEFAULT NULL::uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_kpis jsonb;\r\n    v_overview_chart jsonb;\r\n    v_recent_tasks jsonb;\r\n    v_status_distribution jsonb;\r\n    v_budget_vs_cost jsonb;\r\n    v_project_ids uuid[];\r\n    v_user_id uuid;\r\n    v_auth_role text;\r\nBEGIN\r\n    v_user_id := COALESCE(p_manager_id, auth.uid());\r\n\r\n    IF p_manager_id IS NOT NULL THEN\r\n        SELECT role INTO v_auth_role FROM public.profiles WHERE id = auth.uid();\r\n        IF v_auth_role NOT IN ('Admin', 'Gerente') THEN\r\n            RAISE EXCEPTION 'Apenas administradores ou gerentes podem filtrar por gerente.';\r\n        END IF;\r\n    END IF;\r\n\r\n    IF p_project_id IS NOT NULL THEN\r\n        IF NOT is_project_member(p_project_id, v_user_id) THEN\r\n            RAISE EXCEPTION 'Usuário não tem acesso a este projeto.';\r\n        END IF;\r\n        v_project_ids := ARRAY[p_project_id];\r\n    ELSE\r\n        v_project_ids := ARRAY(SELECT project_id FROM public.collaborators WHERE user_id = v_user_id);\r\n    END IF;\r\n\r\n    IF array_length(v_project_ids, 1) IS NULL THEN\r\n      RETURN jsonb_build_object(\r\n        'kpis', '{}'::jsonb,\r\n        'overview_chart', '[]'::jsonb,\r\n        'recent_tasks', '[]'::jsonb,\r\n        'status_distribution', '[]'::jsonb,\r\n        'budget_vs_cost', '[]'::jsonb\r\n      );\r\n    END IF;\r\n\r\n    -- Subconsulta para tarefas no escopo, para reutilização\r\n    CREATE TEMP TABLE tasks_in_scope AS\r\n    SELECT id, status_id, progress, end_date, project_id, custom_fields, created_at, name, assignee_id\r\n    FROM public.tasks\r\n    WHERE project_id = ANY(v_project_ids);\r\n\r\n    -- 1. Calcula KPIs\r\n    SELECT jsonb_build_object(\r\n        'completed_tasks', (SELECT COUNT(*) FROM tasks_in_scope WHERE status_id = (SELECT id FROM public.task_statuses WHERE name = 'Concluído')),\r\n        'tasks_at_risk', (SELECT COUNT(*) FROM tasks_in_scope WHERE end_date < CURRENT_DATE AND status_id != (SELECT id FROM public.task_statuses WHERE name = 'Concluído')),\r\n        'total_tasks', (SELECT COUNT(*) FROM tasks_in_scope),\r\n        'overall_progress', (SELECT COALESCE(AVG(progress), 0) FROM tasks_in_scope),\r\n        'total_budget', (SELECT COALESCE(SUM(budget), 0) FROM public.projects WHERE id = ANY(v_project_ids))\r\n    ) INTO v_kpis;\r\n\r\n    -- 4. Distribuição por status (CORREÇÃO FINAL)\r\n    SELECT jsonb_agg(status_data ORDER BY display_order) -- Ordena pela ordem definida\r\n    INTO v_status_distribution\r\n    FROM (\r\n        SELECT\r\n            ts.name AS status, -- ALIAS AQUI\r\n            ts.color,\r\n            ts.display_order,\r\n            (SELECT COUNT(*) FROM tasks_in_scope tis WHERE tis.status_id = ts.id) AS task_count\r\n        FROM public.task_statuses ts\r\n    ) AS status_data;\r\n\r\n    -- 2. Visão geral\r\n    WITH months AS (SELECT date_trunc('month', generate_series(NOW() - interval '5 months', NOW(), '1 month'))::date AS month_start)\r\n    SELECT jsonb_agg(chart_data)\r\n    FROM (\r\n        SELECT to_char(m.month_start, 'YYYY-MM') AS month_start,\r\n               COUNT(t.id) FILTER (WHERE ts.name = 'Concluído' AND date_trunc('month', t.end_date)::date = m.month_start) AS completed_count,\r\n               COUNT(t.id) FILTER (WHERE ts.name != 'Concluído' AND date_trunc('month', t.end_date)::date = m.month_start) AS pending_count\r\n        FROM months m CROSS JOIN tasks_in_scope t JOIN task_statuses ts ON t.status_id = ts.id\r\n        GROUP BY m.month_start ORDER BY m.month_start\r\n    ) AS chart_data INTO v_overview_chart;\r\n\r\n    -- 3. Tarefas recentes\r\n    SELECT jsonb_agg(task_data)\r\n    FROM (\r\n        SELECT t.id, t.name, p.name AS project_name, prof.name AS assignee_name, ts.name AS status_name, ts.color AS status_color\r\n        FROM tasks_in_scope t\r\n        JOIN projects p ON t.project_id = p.id\r\n        LEFT JOIN profiles prof ON t.assignee_id = prof.id\r\n        LEFT JOIN task_statuses ts ON t.status_id = ts.id\r\n        ORDER BY t.created_at DESC LIMIT 5\r\n    ) AS task_data INTO v_recent_tasks;\r\n\r\n    -- 5. Orçamento vs Custo\r\n    SELECT jsonb_agg(project_data ORDER BY project)\r\n    INTO v_budget_vs_cost\r\n    FROM (\r\n        SELECT p.name AS project, p.budget,\r\n               COALESCE(SUM((t.custom_fields->>'cost')::numeric), 0) AS cost\r\n        FROM projects p LEFT JOIN tasks_in_scope t ON t.project_id = p.id\r\n        WHERE p.id = ANY(v_project_ids)\r\n        GROUP BY p.id, p.name, p.budget\r\n    ) AS project_data;\r\n    \r\n    DROP TABLE tasks_in_scope;\r\n\r\n    RETURN jsonb_build_object(\r\n        'kpis', v_kpis,\r\n        'overview_chart', COALESCE(v_overview_chart, '[]'::jsonb),\r\n        'recent_tasks', COALESCE(v_recent_tasks, '[]'::jsonb),\r\n        'status_distribution', COALESCE(v_status_distribution, '[]'::jsonb),\r\n        'budget_vs_cost', COALESCE(v_budget_vs_cost, '[]'::jsonb)\r\n    );\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "get_level",
    "definicao": "CREATE OR REPLACE FUNCTION storage.get_level(name text)\n RETURNS integer\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$\nSELECT array_length(string_to_array(\"name\", '/'), 1);\n$function$\n"
  },
  {
    "nome_funcao": "get_my_projects",
    "definicao": "CREATE OR REPLACE FUNCTION public.get_my_projects()\n RETURNS SETOF uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$ BEGIN RETURN QUERY SELECT project_id FROM public.collaborators WHERE user_id = auth.uid(); END; $function$\n"
  },
  {
    "nome_funcao": "get_my_projects_details",
    "definicao": "CREATE OR REPLACE FUNCTION public.get_my_projects_details()\n RETURNS TABLE(id uuid, name text, description text, owner_id uuid, created_at timestamp with time zone, start_date date, end_date date, budget numeric, collaborator_ids uuid[])\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$ BEGIN RETURN QUERY SELECT p.id, p.name, p.description, p.owner_id, p.created_at, p.start_date, p.end_date, p.budget, ARRAY(SELECT c.user_id FROM public.collaborators c WHERE c.project_id = p.id) FROM public.projects p WHERE is_project_member(p.id, auth.uid()); END; $function$\n"
  },
  {
    "nome_funcao": "get_my_projects_ids",
    "definicao": "CREATE OR REPLACE FUNCTION public.get_my_projects_ids()\n RETURNS SETOF uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$ BEGIN RETURN QUERY SELECT id FROM public.projects WHERE is_project_member(id, auth.uid()); END; $function$\n"
  },
  {
    "nome_funcao": "get_overview_chart_data",
    "definicao": "CREATE OR REPLACE FUNCTION public.get_overview_chart_data(p_project_id uuid DEFAULT NULL::uuid)\n RETURNS TABLE(month text, total bigint)\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    done_status_id uuid;\r\nBEGIN\r\n    SELECT id INTO done_status_id FROM public.task_statuses WHERE lower(name) = 'concluído' LIMIT 1;\r\n    RETURN QUERY\r\n    WITH months AS (\r\n      SELECT generate_series(date_trunc('year', now()), date_trunc('year', now()) + interval '11 months', interval '1 month')::date as month\r\n    )\r\n    SELECT to_char(m.month, 'Mon'), count(t.id)\r\n    FROM months m\r\n    LEFT JOIN public.tasks t ON date_trunc('month', t.end_date) = m.month\r\n                           AND t.status_id = done_status_id\r\n                           AND (p_project_id IS NULL OR t.project_id = p_project_id)\r\n                           AND (EXISTS (SELECT 1 FROM public.projects p WHERE p.id = t.project_id AND p.owner_id = auth.uid()) OR\r\n                                EXISTS (SELECT 1 FROM public.collaborators c WHERE c.project_id = t.project_id AND c.user_id = auth.uid()))\r\n    GROUP BY m.month\r\n    ORDER BY m.month;\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "get_prefix",
    "definicao": "CREATE OR REPLACE FUNCTION storage.get_prefix(name text)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$\nSELECT\n    CASE WHEN strpos(\"name\", '/') > 0 THEN\n             regexp_replace(\"name\", '[\\/]{1}[^\\/]+\\/?$', '')\n         ELSE\n             ''\n        END;\n$function$\n"
  },
  {
    "nome_funcao": "get_prefixes",
    "definicao": "CREATE OR REPLACE FUNCTION storage.get_prefixes(name text)\n RETURNS text[]\n LANGUAGE plpgsql\n IMMUTABLE STRICT\nAS $function$\nDECLARE\n    parts text[];\n    prefixes text[];\n    prefix text;\nBEGIN\n    -- Split the name into parts by '/'\n    parts := string_to_array(\"name\", '/');\n    prefixes := '{}';\n\n    -- Construct the prefixes, stopping one level below the last part\n    FOR i IN 1..array_length(parts, 1) - 1 LOOP\n            prefix := array_to_string(parts[1:i], '/');\n            prefixes := array_append(prefixes, prefix);\n    END LOOP;\n\n    RETURN prefixes;\nEND;\n$function$\n"
  },
  {
    "nome_funcao": "get_project_analysis",
    "definicao": "CREATE OR REPLACE FUNCTION public.get_project_analysis(p_project_id uuid, p_baseline_id uuid DEFAULT NULL::uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_kpis jsonb;\r\n    v_status_distribution jsonb;\r\n    v_burndown_data jsonb;\r\n    v_baseline_kpis jsonb;\r\n    v_deviation_chart jsonb;\r\n    v_s_curve_data jsonb;\r\n    v_heatmap_data jsonb;\r\n    v_critical_path_info jsonb;\r\n    v_result jsonb;\r\nBEGIN\r\n    IF NOT is_project_member(p_project_id, auth.uid()) THEN\r\n        RAISE EXCEPTION 'Acesso não autorizado.';\r\n    END IF;\r\n\r\n    IF p_baseline_id IS NOT NULL THEN\r\n        PERFORM 1 FROM public.project_baselines\r\n        WHERE id = p_baseline_id AND project_id = p_project_id;\r\n        IF NOT FOUND THEN\r\n            RAISE EXCEPTION 'Baseline não pertence ao projeto indicado.';\r\n        END IF;\r\n    END IF;\r\n\r\n    SELECT jsonb_build_object(\r\n        'total_tasks', (SELECT COUNT(*) FROM public.tasks WHERE project_id = p_project_id),\r\n        'completed_tasks', (SELECT COUNT(*) FROM public.tasks WHERE project_id = p_project_id AND status_id = (SELECT id FROM public.task_statuses WHERE name = 'Concluído')),\r\n        'overdue_tasks', (SELECT COUNT(*) FROM public.tasks WHERE project_id = p_project_id AND end_date < CURRENT_DATE AND status_id != (SELECT id FROM public.task_statuses WHERE name = 'Concluído'))\r\n    ) INTO v_kpis;\r\n\r\n    SELECT jsonb_agg(json_build_object('name', ts.name, 'task_count', (\r\n            SELECT COUNT(*) FROM tasks WHERE project_id = p_project_id AND status_id = ts.id\r\n        )))\r\n    INTO v_status_distribution\r\n    FROM public.task_statuses ts;\r\n\r\n    SELECT COALESCE(jsonb_agg(json_build_object(\r\n        'date', date,\r\n        'planned_value', planned_value,\r\n        'earned_value', earned_value,\r\n        'actual_cost', actual_cost\r\n    ) ORDER BY date), '[]'::jsonb)\r\n    INTO v_s_curve_data\r\n    FROM public.project_progress\r\n    WHERE project_id = p_project_id;\r\n\r\n    -- Calcula dados de burndown (tarefas planejadas vs concluídas por dia)\r\n    WITH project_dates AS (\r\n        SELECT MIN(start_date) AS start_date, MAX(end_date) AS end_date\r\n        FROM public.tasks\r\n        WHERE project_id = p_project_id\r\n    ),\r\n    date_series AS (\r\n        SELECT generate_series(start_date, end_date, interval '1 day')::date AS date\r\n        FROM project_dates\r\n        WHERE start_date IS NOT NULL AND end_date IS NOT NULL\r\n    ),\r\n    completed_status AS (\r\n        SELECT id AS completed_id FROM public.task_statuses WHERE name = 'Concluído'\r\n    )\r\n    SELECT COALESCE(jsonb_agg(jsonb_build_object(\r\n        'date', ds.date,\r\n        'ideal', (SELECT COUNT(*) FROM public.tasks t WHERE t.project_id = p_project_id AND t.end_date <= ds.date),\r\n        'real', (SELECT COUNT(*) FROM public.tasks t WHERE t.project_id = p_project_id AND t.status_id = cs.completed_id AND t.updated_at::date <= ds.date)\r\n    ) ORDER BY ds.date), '[]'::jsonb)\r\n    INTO v_burndown_data\r\n    FROM date_series ds, completed_status cs;\r\n\r\n    -- Dados para o heatmap: contagem de tarefas por dia e status\r\n    WITH project_dates_hm AS (\r\n        SELECT MIN(start_date) AS start_date, MAX(end_date) AS end_date\r\n        FROM public.tasks\r\n        WHERE project_id = p_project_id\r\n    ),\r\n    date_series_hm AS (\r\n        SELECT generate_series(start_date, end_date, interval '1 day')::date AS date\r\n        FROM project_dates_hm\r\n        WHERE start_date IS NOT NULL AND end_date IS NOT NULL\r\n    ),\r\n    status_list AS (\r\n        SELECT id, name FROM public.task_statuses\r\n    ),\r\n    counts AS (\r\n        SELECT ds.date, sl.name AS status, COUNT(t.id) AS count\r\n        FROM date_series_hm ds\r\n        CROSS JOIN status_list sl\r\n        LEFT JOIN public.tasks t ON t.project_id = p_project_id AND t.status_id = sl.id AND t.end_date = ds.date\r\n        GROUP BY ds.date, sl.name\r\n        ORDER BY ds.date, sl.name\r\n    )\r\n    SELECT COALESCE(jsonb_agg(jsonb_build_object('date', date, 'status', status, 'count', count)), '[]'::jsonb)\r\n    INTO v_heatmap_data\r\n    FROM counts;\r\n\r\n    IF p_baseline_id IS NOT NULL THEN\r\n        WITH baseline_tasks AS (\r\n            SELECT task_id,\r\n                   start_date AS baseline_start_date,\r\n                   end_date   AS baseline_end_date\r\n            FROM task_baselines\r\n            WHERE baseline_id = p_baseline_id\r\n        ),\r\n        current_tasks AS (\r\n            SELECT t.id,\r\n                   t.name,\r\n                   t.start_date AS current_start_date,\r\n                   t.end_date   AS current_end_date,\r\n                   prof.name    AS assignee_name,\r\n                   ts.name      AS status_name\r\n            FROM tasks t\r\n            LEFT JOIN profiles prof ON t.assignee_id = prof.id\r\n            LEFT JOIN task_statuses ts ON t.status_id = ts.id\r\n            WHERE t.project_id = p_project_id\r\n        )\r\n        SELECT\r\n            jsonb_build_object(\r\n                'average_deviation', COALESCE(AVG(ct.current_end_date - bt.baseline_end_date), 0),\r\n                'tasks_delayed', COUNT(*) FILTER (WHERE ct.current_end_date > bt.baseline_end_date)\r\n            ),\r\n            (SELECT jsonb_agg(chart_data) FROM (\r\n                SELECT ct.name,\r\n                       ct.assignee_name,\r\n                       ct.status_name,\r\n                       bt.baseline_start_date,\r\n                       ct.current_start_date,\r\n                       bt.baseline_end_date,\r\n                       ct.current_end_date,\r\n                       (ct.current_end_date - bt.baseline_end_date) AS deviation\r\n                FROM current_tasks ct JOIN baseline_tasks bt ON ct.id = bt.task_id\r\n                WHERE ct.current_end_date IS DISTINCT FROM bt.baseline_end_date\r\n                ORDER BY ABS(ct.current_end_date - bt.baseline_end_date) DESC LIMIT 5\r\n            ) chart_data)\r\n        INTO v_baseline_kpis, v_deviation_chart\r\n        FROM current_tasks ct JOIN baseline_tasks bt ON ct.id = bt.task_id;\r\n    END IF;\r\n\r\n    WITH RECURSIVE task_graph AS (\r\n        SELECT\r\n            t.id,\r\n            GREATEST(0, COALESCE(t.end_date - t.start_date, 0))::integer AS duration,\r\n            ARRAY[t.id] AS path,\r\n            GREATEST(0, COALESCE(t.end_date - t.start_date, 0))::integer AS total_duration\r\n        FROM tasks t\r\n        WHERE t.project_id = p_project_id\r\n          AND NOT EXISTS (SELECT 1 FROM task_dependencies td WHERE td.task_id = t.id)\r\n        UNION ALL\r\n        SELECT\r\n            t.id,\r\n            GREATEST(0, COALESCE(t.end_date - t.start_date, 0))::integer AS duration,\r\n            tg.path || t.id,\r\n            tg.total_duration + GREATEST(0, COALESCE(t.end_date - t.start_date, 0))::integer\r\n        FROM tasks t\r\n        JOIN task_dependencies td ON td.task_id = t.id\r\n        JOIN task_graph tg ON tg.id = td.dependency_id\r\n        WHERE t.project_id = p_project_id\r\n    )\r\n    SELECT jsonb_build_object(\r\n        'path', (SELECT jsonb_agg(t.name ORDER BY ord) FROM unnest(path) WITH ORDINALITY AS p(id, ord) JOIN tasks t ON t.id = p.id),\r\n        'duration', total_duration\r\n    )\r\n    INTO v_critical_path_info\r\n    FROM task_graph\r\n    ORDER BY total_duration DESC\r\n    LIMIT 1;\r\n\r\n    v_result := jsonb_build_object(\r\n        'performance_kpis', v_kpis,\r\n        'status_distribution', v_status_distribution,\r\n        'burndown_data', v_burndown_data,\r\n        's_curve_data', v_s_curve_data,\r\n        'heatmap_data', v_heatmap_data,\r\n        'baseline_kpis', v_baseline_kpis,\r\n        'deviation_chart', v_deviation_chart,\r\n        'criticalPathInfo', COALESCE(v_critical_path_info, '{}'::jsonb)\r\n    );\r\n\r\n    RETURN v_result;\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "get_project_baselines",
    "definicao": "CREATE OR REPLACE FUNCTION public.get_project_baselines(p_project_id uuid)\n RETURNS TABLE(id uuid, project_id uuid, name text, created_at timestamp with time zone, baseline_color text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    IF NOT is_project_member(p_project_id, auth.uid()) THEN\r\n        RAISE EXCEPTION 'Acesso não autorizado para ver as linhas de base deste projeto.';\r\n    END IF;\r\n\r\n    RETURN QUERY\r\n    SELECT pb.id, pb.project_id, pb.name, pb.created_at, pb.color AS baseline_color\r\n    FROM public.project_baselines pb\r\n    WHERE pb.project_id = p_project_id\r\n    ORDER BY pb.created_at DESC;\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "get_project_id_from_path",
    "definicao": "CREATE OR REPLACE FUNCTION public.get_project_id_from_path(p_path_name text)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_project_id_text text;\r\nBEGIN\r\n    v_project_id_text := split_part(p_path_name, '/', 1);\r\n    BEGIN\r\n        RETURN v_project_id_text::uuid;\r\n    EXCEPTION WHEN invalid_text_representation THEN\r\n        RETURN NULL;\r\n    END;\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "get_project_report_data",
    "definicao": "CREATE OR REPLACE FUNCTION public.get_project_report_data(p_project_id uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  v_project_details jsonb;\r\n  v_analysis_data jsonb;\r\n  v_change_history jsonb;\r\n  v_result jsonb;\r\nBEGIN\r\n  -- 1. Validação de permissão\r\n  IF NOT is_project_member(p_project_id, auth.uid()) THEN\r\n    RAISE EXCEPTION 'Acesso não autorizado ao projeto.';\r\n  END IF;\r\n\r\n  -- 2. Coleta de detalhes básicos do projeto\r\n  SELECT to_jsonb(p)\r\n  INTO v_project_details\r\n  FROM public.projects p\r\n  WHERE p.id = p_project_id;\r\n\r\n  -- 3. Reutiliza a função de análise existente para obter KPIs e dados de gráficos\r\n  SELECT get_project_analysis(p_project_id)\r\n  INTO v_analysis_data;\r\n\r\n  -- 4. Coleta o histórico de alterações de datas com justificativas\r\n  SELECT COALESCE(jsonb_agg(ch), '[]'::jsonb)\r\n  INTO v_change_history\r\n  FROM (\r\n    SELECT\r\n      t.name AS task_name,\r\n      th.changed_field,\r\n      th.old_value,\r\n      th.new_value,\r\n      th.justification,\r\n      th.changed_at,\r\n      p.name AS author_name\r\n    FROM public.task_history th\r\n    JOIN public.tasks t ON th.task_id = t.id\r\n    JOIN public.profiles p ON th.user_id = p.id\r\n    WHERE t.project_id = p_project_id\r\n      AND th.changed_field IN ('start_date', 'end_date')\r\n      AND th.justification IS NOT NULL\r\n    ORDER BY th.changed_at DESC\r\n  ) ch;\r\n\r\n  -- 5. Monta o objeto JSON final\r\n  v_result := jsonb_build_object(\r\n    'project_details', v_project_details,\r\n    'analysis', v_analysis_data,\r\n    'change_history', v_change_history\r\n  );\r\n\r\n  RETURN v_result;\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "get_schema_version",
    "definicao": "CREATE OR REPLACE FUNCTION graphql.get_schema_version()\n RETURNS integer\n LANGUAGE sql\n SECURITY DEFINER\nAS $function$\n    select last_value from graphql.seq_schema_version;\n$function$\n"
  },
  {
    "nome_funcao": "get_size_by_bucket",
    "definicao": "CREATE OR REPLACE FUNCTION storage.get_size_by_bucket()\n RETURNS TABLE(size bigint, bucket_id text)\n LANGUAGE plpgsql\n STABLE\nAS $function$\nBEGIN\n    return query\n        select sum((metadata->>'size')::bigint) as size, obj.bucket_id\n        from \"storage\".objects as obj\n        group by obj.bucket_id;\nEND\n$function$\n"
  },
  {
    "nome_funcao": "get_task_observations",
    "definicao": "CREATE OR REPLACE FUNCTION public.get_task_observations(p_task_id uuid)\n RETURNS TABLE(id uuid, task_id uuid, author_id uuid, content text, created_at timestamp with time zone, attachment_url text, updated_at timestamp with time zone, author jsonb)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_project_id uuid;\r\nBEGIN\r\n    -- Obtém o ID do projeto de forma segura\r\n    SELECT project_id INTO v_project_id FROM public.tasks WHERE public.tasks.id = p_task_id;\r\n\r\n    -- Verifica a permissão\r\n    IF NOT is_project_member(v_project_id, auth.uid()) THEN\r\n        RAISE EXCEPTION 'Acesso não autorizado.';\r\n    END IF;\r\n\r\n    -- Retorna os dados, especificando de qual tabela vem cada coluna.\r\n    RETURN QUERY\r\n    SELECT o.id, o.task_id, o.author_id, o.content, o.created_at, o.attachment_url, o.updated_at,\r\n           jsonb_build_object('id', u.id, 'name', u.name, 'avatar_url', u.avatar_url)\r\n    FROM public.task_observations o\r\n    LEFT JOIN public.profiles u ON o.author_id = u.id\r\n    WHERE o.task_id = p_task_id\r\n    ORDER BY o.created_at DESC;\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "get_task_overview_chart_data",
    "definicao": "CREATE OR REPLACE FUNCTION public.get_task_overview_chart_data(p_project_id uuid DEFAULT NULL::uuid)\n RETURNS TABLE(period_start date, completed_count bigint, pending_count bigint)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_user_role text;\r\n    v_user_id uuid := auth.uid();\r\n    v_project_ids uuid[];\r\n    v_start_date date;\r\nBEGIN\r\n    -- 1. Determine user's role and project scope\r\n    SELECT role INTO v_user_role FROM public.profiles WHERE id = v_user_id;\r\n\r\n    IF p_project_id IS NOT NULL THEN\r\n        SELECT ARRAY_AGG(p.id) INTO v_project_ids\r\n        FROM public.projects p\r\n        WHERE p.id = p_project_id AND is_project_member(p.id, v_user_id);\r\n    ELSE\r\n        IF v_user_role = 'Admin' THEN\r\n            SELECT ARRAY_AGG(id) INTO v_project_ids FROM public.projects;\r\n        ELSIF v_user_role = 'Gerente' THEN\r\n            SELECT ARRAY_AGG(id) INTO v_project_ids FROM public.projects WHERE owner_id = v_user_id;\r\n        ELSE\r\n            SELECT ARRAY_AGG(project_id) INTO v_project_ids FROM public.collaborators WHERE user_id = v_user_id;\r\n        END IF;\r\n    END IF;\r\n\r\n    -- If no projects are found for the user, return an empty set cleanly.\r\n    IF v_project_ids IS NULL OR array_length(v_project_ids, 1) = 0 THEN\r\n        RETURN;\r\n    END IF;\r\n\r\n    -- 2. Create a stable 6-month series regardless of data presence\r\n    v_start_date := date_trunc('month', NOW() - interval '5 months');\r\n\r\n    CREATE TEMP TABLE month_series ON COMMIT DROP AS\r\n    SELECT generate_series(v_start_date, date_trunc('month', NOW()), '1 month'::interval)::date AS period_start;\r\n\r\n    -- 3. Calculate task counts safely\r\n    RETURN QUERY\r\n    WITH tasks_in_scope AS (\r\n        SELECT t.id, t.created_at, t.end_date, s.name as status_name\r\n        FROM public.tasks t\r\n        JOIN public.task_statuses s ON t.status_id = s.id\r\n        WHERE t.project_id = ANY(v_project_ids)\r\n    ),\r\n    completed_tasks AS (\r\n        SELECT date_trunc('month', t.end_date)::date AS period, COUNT(t.id) AS count\r\n        FROM tasks_in_scope t\r\n        WHERE t.status_name = 'Concluído' AND t.end_date IS NOT NULL\r\n        GROUP BY period\r\n    ),\r\n    pending_tasks AS (\r\n        SELECT date_trunc('month', t.created_at)::date AS period, COUNT(t.id) AS count\r\n        FROM tasks_in_scope t\r\n        WHERE t.status_name != 'Concluído'\r\n        GROUP BY period\r\n    )\r\n    -- 4. Join the series with the calculated counts\r\n    SELECT\r\n        m.period_start,\r\n        COALESCE(ct.count, 0)::bigint AS completed_count,\r\n        COALESCE(pt.count, 0)::bigint AS pending_count\r\n    FROM month_series m\r\n    LEFT JOIN completed_tasks ct ON m.period_start = ct.period\r\n    LEFT JOIN pending_tasks pt ON m.period_start = pt.period\r\n    ORDER BY m.period_start;\r\n\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "get_tasks_for_project",
    "definicao": "CREATE OR REPLACE FUNCTION public.get_tasks_for_project(p_project_id uuid, p_baseline_id uuid DEFAULT NULL::uuid)\n RETURNS TABLE(id uuid, name text, wbs_code text, description text, project_id uuid, project_name text, assignee_id uuid, assignee_name text, status_id uuid, status_name text, status_color text, priority task_priority, progress integer, start_date date, end_date date, parent_id uuid, is_milestone boolean, tags json, dependencies uuid[], created_at timestamp with time zone, updated_at timestamp with time zone, custom_fields jsonb, baseline_start_date date, baseline_end_date date, baseline_color text)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    SELECT\r\n        t.id,\r\n        t.name,\r\n        '' AS wbs_code,\r\n        t.description,\r\n        t.project_id,\r\n        p.name AS project_name,\r\n        t.assignee_id,\r\n        prof.name AS assignee_name,\r\n        t.status_id,\r\n        ts.name AS status_name,\r\n        ts.color AS status_color,\r\n        t.priority,\r\n        t.progress,\r\n        t.start_date,\r\n        t.end_date,\r\n        t.parent_id,\r\n        t.is_milestone,\r\n        (SELECT json_agg(json_build_object('id', tags.id, 'name', tags.name, 'color', tags.color))\r\n         FROM task_tags tt\r\n         JOIN tags ON tags.id = tt.tag_id\r\n         WHERE tt.task_id = t.id) AS tags,\r\n        (SELECT array_agg(td.dependency_id) \r\n         FROM task_dependencies td \r\n         WHERE td.task_id = t.id) AS dependencies,\r\n        t.created_at,\r\n        t.updated_at,\r\n        t.custom_fields,\r\n        NULL::date AS baseline_start_date, -- Retorna NULL para os campos de baseline\r\n        NULL::date AS baseline_end_date,\r\n        NULL::text AS baseline_color\r\n    FROM\r\n        tasks t\r\n    JOIN\r\n        projects p ON t.project_id = p.id\r\n    LEFT JOIN\r\n        profiles prof ON t.assignee_id = prof.id\r\n    LEFT JOIN\r\n        task_statuses ts ON t.status_id = ts.id\r\n    WHERE\r\n        t.project_id = p_project_id\r\n    ORDER BY\r\n        t.created_at;\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "get_tasks_for_project",
    "definicao": "CREATE OR REPLACE FUNCTION public.get_tasks_for_project(p_project_id uuid, p_baseline_ids uuid[] DEFAULT NULL::uuid[])\n RETURNS TABLE(id uuid, formatted_id text, name text, description text, assignee_id uuid, status_id uuid, priority text, start_date date, end_date date, progress integer, parent_id uuid, is_milestone boolean, created_at timestamp with time zone, project_id uuid, project_name text, assignee_name text, status_name text, status_color text, tags json, custom_fields jsonb, dependency_ids uuid[], baseline_data jsonb)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    IF NOT is_project_member(p_project_id, auth.uid()) THEN\r\n        RETURN;\r\n    END IF;\r\n\r\n    RETURN QUERY\r\n    WITH baselines AS (\r\n        SELECT\r\n            bt.task_id,\r\n            jsonb_agg(jsonb_build_object(\r\n                'id', pb.id,\r\n                'name', pb.name,\r\n                'start_date', bt.start_date,\r\n                'end_date', bt.end_date,\r\n                'color', pb.color\r\n            )) AS baseline_data\r\n        FROM public.task_baselines bt\r\n        JOIN public.project_baselines pb ON bt.baseline_id = pb.id\r\n        WHERE (p_baseline_ids IS NULL OR bt.baseline_id = ANY(p_baseline_ids))\r\n        GROUP BY bt.task_id\r\n    )\r\n    SELECT\r\n        t.id,\r\n        'TSK-' || lpad(t.task_serial_id::text, 4, '0'),\r\n        t.name,\r\n        t.description,\r\n        t.assignee_id,\r\n        t.status_id,\r\n        t.priority::text,\r\n        t.start_date,\r\n        t.end_date,\r\n        t.progress,\r\n        t.parent_id,\r\n        t.is_milestone,\r\n        t.created_at,\r\n        t.project_id,\r\n        p.name AS project_name,\r\n        prof.name AS assignee_name,\r\n        ts.name AS status_name,\r\n        ts.color AS status_color,\r\n        (SELECT json_agg(tags_agg) FROM (\r\n            SELECT tg.* FROM public.task_tags tt JOIN public.tags tg ON tt.tag_id = tg.id WHERE tt.task_id = t.id\r\n        ) tags_agg) AS tags,\r\n        t.custom_fields,\r\n        ARRAY(SELECT td.dependency_id FROM public.task_dependencies td WHERE td.task_id = t.id) AS dependency_ids,\r\n        b.baseline_data\r\n    FROM public.tasks t\r\n    LEFT JOIN public.projects p ON t.project_id = p.id\r\n    LEFT JOIN public.profiles prof ON t.assignee_id = prof.id\r\n    LEFT JOIN public.task_statuses ts ON t.status_id = ts.id\r\n    LEFT JOIN baselines b ON t.id = b.task_id\r\n    WHERE t.project_id = p_project_id;\r\n\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "get_user_role",
    "definicao": "CREATE OR REPLACE FUNCTION public.get_user_role(p_user_id uuid)\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$ DECLARE user_role TEXT; BEGIN SELECT role INTO user_role FROM public.profiles WHERE id = p_user_id; RETURN user_role; END; $function$\n"
  },
  {
    "nome_funcao": "grant_pg_cron_access",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.grant_pg_cron_access()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  IF EXISTS (\n    SELECT\n    FROM pg_event_trigger_ddl_commands() AS ev\n    JOIN pg_extension AS ext\n    ON ev.objid = ext.oid\n    WHERE ext.extname = 'pg_cron'\n  )\n  THEN\n    grant usage on schema cron to postgres with grant option;\n\n    alter default privileges in schema cron grant all on tables to postgres with grant option;\n    alter default privileges in schema cron grant all on functions to postgres with grant option;\n    alter default privileges in schema cron grant all on sequences to postgres with grant option;\n\n    alter default privileges for user supabase_admin in schema cron grant all\n        on sequences to postgres with grant option;\n    alter default privileges for user supabase_admin in schema cron grant all\n        on tables to postgres with grant option;\n    alter default privileges for user supabase_admin in schema cron grant all\n        on functions to postgres with grant option;\n\n    grant all privileges on all tables in schema cron to postgres with grant option;\n    revoke all on table cron.job from postgres;\n    grant select on table cron.job to postgres with grant option;\n  END IF;\nEND;\n$function$\n"
  },
  {
    "nome_funcao": "grant_pg_graphql_access",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.grant_pg_graphql_access()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    func_is_graphql_resolve bool;\nBEGIN\n    func_is_graphql_resolve = (\n        SELECT n.proname = 'resolve'\n        FROM pg_event_trigger_ddl_commands() AS ev\n        LEFT JOIN pg_catalog.pg_proc AS n\n        ON ev.objid = n.oid\n    );\n\n    IF func_is_graphql_resolve\n    THEN\n        -- Update public wrapper to pass all arguments through to the pg_graphql resolve func\n        DROP FUNCTION IF EXISTS graphql_public.graphql;\n        create or replace function graphql_public.graphql(\n            \"operationName\" text default null,\n            query text default null,\n            variables jsonb default null,\n            extensions jsonb default null\n        )\n            returns jsonb\n            language sql\n        as $$\n            select graphql.resolve(\n                query := query,\n                variables := coalesce(variables, '{}'),\n                \"operationName\" := \"operationName\",\n                extensions := extensions\n            );\n        $$;\n\n        -- This hook executes when `graphql.resolve` is created. That is not necessarily the last\n        -- function in the extension so we need to grant permissions on existing entities AND\n        -- update default permissions to any others that are created after `graphql.resolve`\n        grant usage on schema graphql to postgres, anon, authenticated, service_role;\n        grant select on all tables in schema graphql to postgres, anon, authenticated, service_role;\n        grant execute on all functions in schema graphql to postgres, anon, authenticated, service_role;\n        grant all on all sequences in schema graphql to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on tables to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on functions to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on sequences to postgres, anon, authenticated, service_role;\n\n        -- Allow postgres role to allow granting usage on graphql and graphql_public schemas to custom roles\n        grant usage on schema graphql_public to postgres with grant option;\n        grant usage on schema graphql to postgres with grant option;\n    END IF;\n\nEND;\n$function$\n"
  },
  {
    "nome_funcao": "grant_pg_net_access",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.grant_pg_net_access()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  IF EXISTS (\n    SELECT 1\n    FROM pg_event_trigger_ddl_commands() AS ev\n    JOIN pg_extension AS ext\n    ON ev.objid = ext.oid\n    WHERE ext.extname = 'pg_net'\n  )\n  THEN\n    IF NOT EXISTS (\n      SELECT 1\n      FROM pg_roles\n      WHERE rolname = 'supabase_functions_admin'\n    )\n    THEN\n      CREATE USER supabase_functions_admin NOINHERIT CREATEROLE LOGIN NOREPLICATION;\n    END IF;\n\n    GRANT USAGE ON SCHEMA net TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n\n    IF EXISTS (\n      SELECT FROM pg_extension\n      WHERE extname = 'pg_net'\n      -- all versions in use on existing projects as of 2025-02-20\n      -- version 0.12.0 onwards don't need these applied\n      AND extversion IN ('0.2', '0.6', '0.7', '0.7.1', '0.8', '0.10.0', '0.11.0')\n    ) THEN\n      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;\n      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;\n\n      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;\n      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;\n\n      REVOKE ALL ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;\n      REVOKE ALL ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;\n\n      GRANT EXECUTE ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n      GRANT EXECUTE ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n    END IF;\n  END IF;\nEND;\n$function$\n"
  },
  {
    "nome_funcao": "graphql",
    "definicao": "CREATE OR REPLACE FUNCTION graphql_public.graphql(\"operationName\" text DEFAULT NULL::text, query text DEFAULT NULL::text, variables jsonb DEFAULT NULL::jsonb, extensions jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE sql\nAS $function$\n            select graphql.resolve(\n                query := query,\n                variables := coalesce(variables, '{}'),\n                \"operationName\" := \"operationName\",\n                extensions := extensions\n            );\n        $function$\n"
  },
  {
    "nome_funcao": "handle_new_user",
    "definicao": "CREATE OR REPLACE FUNCTION public.handle_new_user()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n  INSERT INTO public.profiles (id, email, name, avatar_url)\r\n  VALUES (\r\n    NEW.id,\r\n    NEW.email,\r\n    NEW.raw_user_meta_data->>'full_name',\r\n    NEW.raw_user_meta_data->>'avatar_url'\r\n  );\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "hmac",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.hmac(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_hmac$function$\n"
  },
  {
    "nome_funcao": "hmac",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.hmac(text, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_hmac$function$\n"
  },
  {
    "nome_funcao": "http",
    "definicao": "CREATE OR REPLACE FUNCTION public.http(request http_request)\n RETURNS http_response\n LANGUAGE c\nAS '$libdir/http', $function$http_request$function$\n"
  },
  {
    "nome_funcao": "http_collect_response",
    "definicao": "CREATE OR REPLACE FUNCTION net.http_collect_response(request_id bigint, async boolean DEFAULT true)\n RETURNS net.http_response_result\n LANGUAGE plpgsql\n PARALLEL SAFE STRICT\nAS $function$\nbegin\n  raise notice 'The net.http_collect_response function is deprecated.';\n  select net._http_collect_response(request_id, async);\nend;\n$function$\n"
  },
  {
    "nome_funcao": "http_delete",
    "definicao": "CREATE OR REPLACE FUNCTION public.http_delete(uri character varying)\n RETURNS http_response\n LANGUAGE sql\nAS $function$ SELECT public.http(('DELETE', $1, NULL, NULL, NULL)::public.http_request) $function$\n"
  },
  {
    "nome_funcao": "http_delete",
    "definicao": "CREATE OR REPLACE FUNCTION public.http_delete(uri character varying, content character varying, content_type character varying)\n RETURNS http_response\n LANGUAGE sql\nAS $function$ SELECT public.http(('DELETE', $1, NULL, $3, $2)::public.http_request) $function$\n"
  },
  {
    "nome_funcao": "http_delete",
    "definicao": "CREATE OR REPLACE FUNCTION net.http_delete(url text, params jsonb DEFAULT '{}'::jsonb, headers jsonb DEFAULT '{}'::jsonb, timeout_milliseconds integer DEFAULT 5000)\n RETURNS bigint\n LANGUAGE plpgsql\n PARALLEL SAFE STRICT\nAS $function$\ndeclare\n    request_id bigint;\n    params_array text[];\nbegin\n    select coalesce(array_agg(net._urlencode_string(key) || '=' || net._urlencode_string(value)), '{}')\n    into params_array\n    from jsonb_each_text(params);\n\n    -- Add to the request queue\n    insert into net.http_request_queue(method, url, headers, timeout_milliseconds)\n    values (\n        'DELETE',\n        net._encode_url_with_params_array(url, params_array),\n        headers,\n        timeout_milliseconds\n    )\n    returning id\n    into request_id;\n\n    return request_id;\nend\n$function$\n"
  },
  {
    "nome_funcao": "http_get",
    "definicao": "CREATE OR REPLACE FUNCTION public.http_get(uri character varying)\n RETURNS http_response\n LANGUAGE sql\nAS $function$ SELECT public.http(('GET', $1, NULL, NULL, NULL)::public.http_request) $function$\n"
  },
  {
    "nome_funcao": "http_get",
    "definicao": "CREATE OR REPLACE FUNCTION public.http_get(uri character varying, data jsonb)\n RETURNS http_response\n LANGUAGE sql\nAS $function$\n        SELECT public.http(('GET', $1 || '?' || public.urlencode($2), NULL, NULL, NULL)::public.http_request)\n    $function$\n"
  },
  {
    "nome_funcao": "http_get",
    "definicao": "CREATE OR REPLACE FUNCTION net.http_get(url text, params jsonb DEFAULT '{}'::jsonb, headers jsonb DEFAULT '{}'::jsonb, timeout_milliseconds integer DEFAULT 5000)\n RETURNS bigint\n LANGUAGE plpgsql\n PARALLEL SAFE STRICT\nAS $function$\ndeclare\n    request_id bigint;\n    params_array text[];\nbegin\n    select coalesce(array_agg(net._urlencode_string(key) || '=' || net._urlencode_string(value)), '{}')\n    into params_array\n    from jsonb_each_text(params);\n\n    -- Add to the request queue\n    insert into net.http_request_queue(method, url, headers, timeout_milliseconds)\n    values (\n        'GET',\n        net._encode_url_with_params_array(url, params_array),\n        headers,\n        timeout_milliseconds\n    )\n    returning id\n    into request_id;\n\n    return request_id;\nend\n$function$\n"
  },
  {
    "nome_funcao": "http_head",
    "definicao": "CREATE OR REPLACE FUNCTION public.http_head(uri character varying)\n RETURNS http_response\n LANGUAGE sql\nAS $function$ SELECT public.http(('HEAD', $1, NULL, NULL, NULL)::public.http_request) $function$\n"
  },
  {
    "nome_funcao": "http_header",
    "definicao": "CREATE OR REPLACE FUNCTION public.http_header(field character varying, value character varying)\n RETURNS http_header\n LANGUAGE sql\nAS $function$ SELECT $1, $2 $function$\n"
  },
  {
    "nome_funcao": "http_list_curlopt",
    "definicao": "CREATE OR REPLACE FUNCTION public.http_list_curlopt()\n RETURNS TABLE(curlopt text, value text)\n LANGUAGE c\nAS '$libdir/http', $function$http_list_curlopt$function$\n"
  },
  {
    "nome_funcao": "http_patch",
    "definicao": "CREATE OR REPLACE FUNCTION public.http_patch(uri character varying, content character varying, content_type character varying)\n RETURNS http_response\n LANGUAGE sql\nAS $function$ SELECT public.http(('PATCH', $1, NULL, $3, $2)::public.http_request) $function$\n"
  },
  {
    "nome_funcao": "http_post",
    "definicao": "CREATE OR REPLACE FUNCTION public.http_post(uri character varying, data jsonb)\n RETURNS http_response\n LANGUAGE sql\nAS $function$\n        SELECT public.http(('POST', $1, NULL, 'application/x-www-form-urlencoded', public.urlencode($2))::public.http_request)\n    $function$\n"
  },
  {
    "nome_funcao": "http_post",
    "definicao": "CREATE OR REPLACE FUNCTION public.http_post(uri character varying, content character varying, content_type character varying)\n RETURNS http_response\n LANGUAGE sql\nAS $function$ SELECT public.http(('POST', $1, NULL, $3, $2)::public.http_request) $function$\n"
  },
  {
    "nome_funcao": "http_post",
    "definicao": "CREATE OR REPLACE FUNCTION net.http_post(url text, body jsonb DEFAULT '{}'::jsonb, params jsonb DEFAULT '{}'::jsonb, headers jsonb DEFAULT '{\"Content-Type\": \"application/json\"}'::jsonb, timeout_milliseconds integer DEFAULT 5000)\n RETURNS bigint\n LANGUAGE plpgsql\n PARALLEL SAFE\nAS $function$\ndeclare\n    request_id bigint;\n    params_array text[];\n    content_type text;\nbegin\n\n    -- Exctract the content_type from headers\n    select\n        header_value into content_type\n    from\n        jsonb_each_text(coalesce(headers, '{}'::jsonb)) r(header_name, header_value)\n    where\n        lower(header_name) = 'content-type'\n    limit\n        1;\n\n    -- If the user provided new headers and omitted the content type\n    -- add it back in automatically\n    if content_type is null then\n        select headers || '{\"Content-Type\": \"application/json\"}'::jsonb into headers;\n    end if;\n\n    -- Confirm that the content-type is set as \"application/json\"\n    if content_type <> 'application/json' then\n        raise exception 'Content-Type header must be \"application/json\"';\n    end if;\n\n    select\n        coalesce(array_agg(net._urlencode_string(key) || '=' || net._urlencode_string(value)), '{}')\n    into\n        params_array\n    from\n        jsonb_each_text(params);\n\n    -- Add to the request queue\n    insert into net.http_request_queue(method, url, headers, body, timeout_milliseconds)\n    values (\n        'POST',\n        net._encode_url_with_params_array(url, params_array),\n        headers,\n        convert_to(body::text, 'UTF8'),\n        timeout_milliseconds\n    )\n    returning id\n    into request_id;\n\n    return request_id;\nend\n$function$\n"
  },
  {
    "nome_funcao": "http_put",
    "definicao": "CREATE OR REPLACE FUNCTION public.http_put(uri character varying, content character varying, content_type character varying)\n RETURNS http_response\n LANGUAGE sql\nAS $function$ SELECT public.http(('PUT', $1, NULL, $3, $2)::public.http_request) $function$\n"
  },
  {
    "nome_funcao": "http_reset_curlopt",
    "definicao": "CREATE OR REPLACE FUNCTION public.http_reset_curlopt()\n RETURNS boolean\n LANGUAGE c\nAS '$libdir/http', $function$http_reset_curlopt$function$\n"
  },
  {
    "nome_funcao": "http_set_curlopt",
    "definicao": "CREATE OR REPLACE FUNCTION public.http_set_curlopt(curlopt character varying, value character varying)\n RETURNS boolean\n LANGUAGE c\nAS '$libdir/http', $function$http_set_curlopt$function$\n"
  },
  {
    "nome_funcao": "import_tasks_data",
    "definicao": "CREATE OR REPLACE FUNCTION public.import_tasks_data(p_project_id uuid, p_tasks jsonb)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  task_record jsonb;\r\nBEGIN\r\n  FOR task_record IN SELECT * FROM jsonb_array_elements(p_tasks)\r\n  LOOP\r\n    BEGIN\r\n      INSERT INTO public.tasks (\r\n        project_id,\r\n        name,\r\n        description,\r\n        assignee_id,\r\n        status_id,\r\n        priority,\r\n        progress,\r\n        start_date,\r\n        end_date,\r\n        parent_id,\r\n        custom_fields\r\n      )\r\n      VALUES (\r\n        p_project_id,\r\n        (task_record->>'name')::text,\r\n        (task_record->>'description')::text,\r\n        (task_record->>'assignee_id')::uuid,\r\n        (task_record->>'status_id')::uuid,\r\n        (task_record->>'priority')::task_priority,\r\n        (task_record->>'progress')::integer,\r\n        (task_record->>'start_date')::date,\r\n        (task_record->>'end_date')::date,\r\n        (task_record->>'parent_id')::uuid,\r\n        (task_record->'custom_fields')::jsonb\r\n      );\r\n    EXCEPTION\r\n      WHEN others THEN\r\n        RAISE NOTICE 'Falha ao importar a tarefa: % . Erro: %', task_record->>'name', SQLERRM;\r\n    END;\r\n  END LOOP;\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "increment_schema_version",
    "definicao": "CREATE OR REPLACE FUNCTION graphql.increment_schema_version()\n RETURNS event_trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nbegin\n    perform pg_catalog.nextval('graphql.seq_schema_version');\nend;\n$function$\n"
  },
  {
    "nome_funcao": "is_project_manager",
    "definicao": "CREATE OR REPLACE FUNCTION public.is_project_manager(p_project_id uuid, p_user_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n  RETURN EXISTS (\r\n    SELECT 1\r\n    FROM public.projects p\r\n    WHERE p.id = p_project_id AND p.owner_id = p_user_id\r\n  ) OR EXISTS (\r\n    SELECT 1\r\n    FROM public.collaborators c\r\n    WHERE c.project_id = p_project_id\r\n      AND c.user_id = p_user_id\r\n      AND c.role = 'Gerente'\r\n  );\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "is_project_member",
    "definicao": "CREATE OR REPLACE FUNCTION public.is_project_member(p_project_id uuid)\n RETURNS boolean\n LANGUAGE sql\n STABLE SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\n  SELECT EXISTS (\r\n    SELECT 1\r\n    FROM public.collaborators c\r\n    WHERE c.project_id = p_project_id\r\n      AND c.user_id = auth.uid()\r\n  );\r\n$function$\n"
  },
  {
    "nome_funcao": "is_project_member",
    "definicao": "CREATE OR REPLACE FUNCTION public.is_project_member(p_project_id uuid, p_user_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- This check now correctly uses the session of the user making the request.\r\n    RETURN EXISTS (SELECT 1 FROM public.projects p WHERE p.id = p_project_id AND p.owner_id = p_user_id)\r\n        OR EXISTS (SELECT 1 FROM public.collaborators c WHERE c.project_id = p_project_id AND c.user_id = p_user_id);\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "is_visible_through_filters",
    "definicao": "CREATE OR REPLACE FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[])\n RETURNS boolean\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n    /*\n    Should the record be visible (true) or filtered out (false) after *filters* are applied\n    */\n        select\n            -- Default to allowed when no filters present\n            $2 is null -- no filters. this should not happen because subscriptions has a default\n            or array_length($2, 1) is null -- array length of an empty array is null\n            or bool_and(\n                coalesce(\n                    realtime.check_equality_op(\n                        op:=f.op,\n                        type_:=coalesce(\n                            col.type_oid::regtype, -- null when wal2json version <= 2.4\n                            col.type_name::regtype\n                        ),\n                        -- cast jsonb to text\n                        val_1:=col.value #>> '{}',\n                        val_2:=f.value\n                    ),\n                    false -- if null, filter does not match\n                )\n            )\n        from\n            unnest(filters) f\n            join unnest(columns) col\n                on f.column_name = col.name;\n    $function$\n"
  },
  {
    "nome_funcao": "jwt",
    "definicao": "CREATE OR REPLACE FUNCTION auth.jwt()\n RETURNS jsonb\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n    coalesce(\n        nullif(current_setting('request.jwt.claim', true), ''),\n        nullif(current_setting('request.jwt.claims', true), '')\n    )::jsonb\n$function$\n"
  },
  {
    "nome_funcao": "list_changes",
    "definicao": "CREATE OR REPLACE FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer)\n RETURNS SETOF realtime.wal_rls\n LANGUAGE sql\n SET log_min_messages TO 'fatal'\nAS $function$\n      with pub as (\n        select\n          concat_ws(\n            ',',\n            case when bool_or(pubinsert) then 'insert' else null end,\n            case when bool_or(pubupdate) then 'update' else null end,\n            case when bool_or(pubdelete) then 'delete' else null end\n          ) as w2j_actions,\n          coalesce(\n            string_agg(\n              realtime.quote_wal2json(format('%I.%I', schemaname, tablename)::regclass),\n              ','\n            ) filter (where ppt.tablename is not null and ppt.tablename not like '% %'),\n            ''\n          ) w2j_add_tables\n        from\n          pg_publication pp\n          left join pg_publication_tables ppt\n            on pp.pubname = ppt.pubname\n        where\n          pp.pubname = publication\n        group by\n          pp.pubname\n        limit 1\n      ),\n      w2j as (\n        select\n          x.*, pub.w2j_add_tables\n        from\n          pub,\n          pg_logical_slot_get_changes(\n            slot_name, null, max_changes,\n            'include-pk', 'true',\n            'include-transaction', 'false',\n            'include-timestamp', 'true',\n            'include-type-oids', 'true',\n            'format-version', '2',\n            'actions', pub.w2j_actions,\n            'add-tables', pub.w2j_add_tables\n          ) x\n      )\n      select\n        xyz.wal,\n        xyz.is_rls_enabled,\n        xyz.subscription_ids,\n        xyz.errors\n      from\n        w2j,\n        realtime.apply_rls(\n          wal := w2j.data::jsonb,\n          max_record_bytes := max_record_bytes\n        ) xyz(wal, is_rls_enabled, subscription_ids, errors)\n      where\n        w2j.w2j_add_tables <> ''\n        and xyz.subscription_ids[1] is not null\n    $function$\n"
  },
  {
    "nome_funcao": "list_multipart_uploads_with_delimiter",
    "definicao": "CREATE OR REPLACE FUNCTION storage.list_multipart_uploads_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, next_key_token text DEFAULT ''::text, next_upload_token text DEFAULT ''::text)\n RETURNS TABLE(key text, id text, created_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY EXECUTE\n        'SELECT DISTINCT ON(key COLLATE \"C\") * from (\n            SELECT\n                CASE\n                    WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN\n                        substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1)))\n                    ELSE\n                        key\n                END AS key, id, created_at\n            FROM\n                storage.s3_multipart_uploads\n            WHERE\n                bucket_id = $5 AND\n                key ILIKE $1 || ''%'' AND\n                CASE\n                    WHEN $4 != '''' AND $6 = '''' THEN\n                        CASE\n                            WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN\n                                substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1))) COLLATE \"C\" > $4\n                            ELSE\n                                key COLLATE \"C\" > $4\n                            END\n                    ELSE\n                        true\n                END AND\n                CASE\n                    WHEN $6 != '''' THEN\n                        id COLLATE \"C\" > $6\n                    ELSE\n                        true\n                    END\n            ORDER BY\n                key COLLATE \"C\" ASC, created_at ASC) as e order by key COLLATE \"C\" LIMIT $3'\n        USING prefix_param, delimiter_param, max_keys, next_key_token, bucket_id, next_upload_token;\nEND;\n$function$\n"
  },
  {
    "nome_funcao": "list_objects_with_delimiter",
    "definicao": "CREATE OR REPLACE FUNCTION storage.list_objects_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, start_after text DEFAULT ''::text, next_token text DEFAULT ''::text)\n RETURNS TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY EXECUTE\n        'SELECT DISTINCT ON(name COLLATE \"C\") * from (\n            SELECT\n                CASE\n                    WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN\n                        substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1)))\n                    ELSE\n                        name\n                END AS name, id, metadata, updated_at\n            FROM\n                storage.objects\n            WHERE\n                bucket_id = $5 AND\n                name ILIKE $1 || ''%'' AND\n                CASE\n                    WHEN $6 != '''' THEN\n                    name COLLATE \"C\" > $6\n                ELSE true END\n                AND CASE\n                    WHEN $4 != '''' THEN\n                        CASE\n                            WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN\n                                substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1))) COLLATE \"C\" > $4\n                            ELSE\n                                name COLLATE \"C\" > $4\n                            END\n                    ELSE\n                        true\n                END\n            ORDER BY\n                name COLLATE \"C\" ASC) as e order by name COLLATE \"C\" LIMIT $3'\n        USING prefix_param, delimiter_param, max_keys, next_token, bucket_id, start_after;\nEND;\n$function$\n"
  },
  {
    "nome_funcao": "manage_project",
    "definicao": "CREATE OR REPLACE FUNCTION public.manage_project(p_project_id uuid, p_name text, p_description text, p_start_date text, p_end_date text, p_status text)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_project_id uuid;\r\n    v_user_id uuid = auth.uid();\r\nBEGIN\r\n    -- If p_project_id is null, it's a new project\r\n    IF p_project_id IS NULL THEN\r\n        -- User must be a project manager or admin to create.\r\n        -- Note: This check might be adjusted based on business logic for who can create projects.\r\n        -- For now, we assume any authenticated user can create a project.\r\n        \r\n        INSERT INTO public.projects (name, description, start_date, end_date, status, updated_at, created_by)\r\n        VALUES (p_name, p_description, p_start_date::date, p_end_date::date, p_status, now(), v_user_id)\r\n        RETURNING id INTO v_project_id;\r\n\r\n        -- Automatically add the creator as a 'Project Manager' collaborator\r\n        INSERT INTO public.project_collaborators (project_id, user_id, role)\r\n        VALUES (v_project_id, v_user_id, 'Project Manager');\r\n\r\n    -- If p_project_id is not null, it's an existing project\r\n    ELSE\r\n        -- First, check if the user has permission to edit this project\r\n        IF NOT is_project_member(p_project_id, v_user_id) THEN\r\n            RAISE EXCEPTION 'User does not have permission to edit this project';\r\n        END IF;\r\n\r\n        UPDATE public.projects\r\n        SET\r\n            name = p_name,\r\n            description = p_description,\r\n            start_date = p_start_date::date,\r\n            end_date = p_end_date::date,\r\n            status = p_status,\r\n            updated_at = now()\r\n        WHERE id = p_project_id;\r\n        \r\n        v_project_id := p_project_id;\r\n    END IF;\r\n\r\n    RETURN v_project_id;\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "manage_project",
    "definicao": "CREATE OR REPLACE FUNCTION public.manage_project(p_project_id uuid, p_name text, p_description text, p_start_date date, p_end_date date, p_collaborator_ids uuid[])\n RETURNS uuid\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_project_id uuid;\r\n    v_owner_id uuid := auth.uid();\r\nBEGIN\r\n    IF p_project_id IS NULL THEN\r\n        -- INSERT: Inclui as novas datas\r\n        INSERT INTO public.projects (name, description, owner_id, start_date, end_date)\r\n        VALUES (p_name, p_description, v_owner_id, p_start_date, p_end_date)\r\n        RETURNING id INTO v_project_id;\r\n\r\n        -- O dono é sempre um colaborador\r\n        INSERT INTO public.collaborators (project_id, user_id, role)\r\n        VALUES (v_project_id, v_owner_id, 'Gerente'::collaborator_role)\r\n        ON CONFLICT (project_id, user_id) DO NOTHING;\r\n    ELSE\r\n        -- UPDATE: Inclui as novas datas\r\n        UPDATE public.projects\r\n        SET \r\n            name = p_name, \r\n            description = p_description, \r\n            start_date = p_start_date,\r\n            end_date = p_end_date,\r\n            updated_at = now()\r\n        WHERE id = p_project_id\r\n        RETURNING id INTO v_project_id;\r\n    END IF;\r\n\r\n    -- Gerenciamento de colaboradores\r\n    DELETE FROM public.collaborators\r\n    WHERE project_id = v_project_id\r\n      AND user_id != v_owner_id\r\n      AND user_id NOT IN (SELECT unnest(p_collaborator_ids));\r\n\r\n    IF array_length(p_collaborator_ids, 1) > 0 THEN\r\n        INSERT INTO public.collaborators (project_id, user_id, role)\r\n        SELECT v_project_id, unnest(p_collaborator_ids), 'Membro'::collaborator_role\r\n        ON CONFLICT (project_id, user_id) DO NOTHING;\r\n    END IF;\r\n    \r\n    RETURN v_project_id;\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "manage_project",
    "definicao": "CREATE OR REPLACE FUNCTION public.manage_project(p_project_id uuid, p_name text, p_description text, p_start_date date, p_end_date date, p_budget numeric, p_collaborator_ids uuid[])\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_project_id uuid;\r\n    v_owner_id uuid := auth.uid();\r\nBEGIN\r\n    -- Apenas o dono do projeto pode editá-lo.\r\n    IF p_project_id IS NOT NULL AND NOT (SELECT owner_id = v_owner_id FROM public.projects WHERE id = p_project_id) THEN\r\n        RAISE EXCEPTION 'Only the project owner can edit the project.';\r\n    END IF;\r\n\r\n    -- Se não houver ID, cria um novo projeto.\r\n    IF p_project_id IS NULL THEN\r\n        INSERT INTO public.projects (name, description, owner_id, start_date, end_date, budget)\r\n        VALUES (p_name, p_description, v_owner_id, p_start_date, p_end_date, p_budget)\r\n        RETURNING id INTO v_project_id;\r\n        \r\n        -- Adiciona o dono como Gerente.\r\n        INSERT INTO public.collaborators (project_id, user_id, role)\r\n        VALUES (v_project_id, v_owner_id, 'Gerente'::collaborator_role)\r\n        ON CONFLICT (project_id, user_id) DO NOTHING;\r\n    -- Se houver ID, atualiza o projeto existente.\r\n    ELSE\r\n        UPDATE public.projects\r\n        SET name = p_name,\r\n            description = p_description,\r\n            start_date = p_start_date,\r\n            end_date = p_end_date,\r\n            budget = p_budget,\r\n            updated_at = now()\r\n        WHERE id = p_project_id\r\n        RETURNING id INTO v_project_id;\r\n    END IF;\r\n\r\n    -- Sincroniza a lista de colaboradores.\r\n    DELETE FROM public.collaborators\r\n    WHERE project_id = v_project_id\r\n      AND user_id != v_owner_id -- Não remove o dono\r\n      AND user_id NOT IN (SELECT unnest(p_collaborator_ids));\r\n\r\n    IF array_length(p_collaborator_ids, 1) > 0 THEN\r\n        INSERT INTO public.collaborators (project_id, user_id, role)\r\n        SELECT v_project_id, unnest(p_collaborator_ids), 'Membro'::collaborator_role\r\n        ON CONFLICT (project_id, user_id) DO NOTHING;\r\n    END IF;\r\n\r\n    RETURN v_project_id;\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "manage_task",
    "definicao": "CREATE OR REPLACE FUNCTION public.manage_task(p_assignee_id uuid, p_custom_fields jsonb, p_dependency_ids uuid[], p_description text, p_end_date date, p_name text, p_parent_id uuid, p_priority text, p_progress integer, p_project_id uuid, p_start_date date, p_status_id uuid, p_tag_ids uuid[], p_task_id uuid)\n RETURNS uuid\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_task_id uuid;\r\nBEGIN\r\n    IF NOT is_project_member(p_project_id, auth.uid()) THEN\r\n        RAISE EXCEPTION 'User does not have permission to manage tasks in this project';\r\n    END IF;\r\n\r\n    IF p_task_id IS NULL THEN\r\n        INSERT INTO public.tasks (project_id, name, description, assignee_id, status_id, priority, progress, start_date, end_date, parent_id, custom_fields)\r\n        VALUES (p_project_id, p_name, p_description, p_assignee_id, p_status_id, p_priority::task_priority, p_progress, p_start_date, p_end_date, p_parent_id, p_custom_fields)\r\n        RETURNING id INTO v_task_id;\r\n    ELSE\r\n        UPDATE public.tasks\r\n        SET name = p_name, description = p_description, assignee_id = p_assignee_id, status_id = p_status_id, priority = p_priority::task_priority, progress = p_progress, start_date = p_start_date, end_date = p_end_date, parent_id = p_parent_id, custom_fields = p_custom_fields, updated_at = now()\r\n        WHERE id = p_task_id\r\n        RETURNING id INTO v_task_id;\r\n    END IF;\r\n\r\n    DELETE FROM public.task_tags WHERE task_id = v_task_id;\r\n    IF array_length(p_tag_ids, 1) > 0 THEN INSERT INTO public.task_tags (task_id, tag_id) SELECT v_task_id, unnest(p_tag_ids); END IF;\r\n    \r\n    DELETE FROM public.task_dependencies WHERE task_id = v_task_id;\r\n    IF array_length(p_dependency_ids, 1) > 0 THEN INSERT INTO public.task_dependencies (task_id, dependency_id) SELECT v_task_id, unnest(p_dependency_ids); END IF;\r\n    \r\n    RETURN v_task_id;\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "manage_task",
    "definicao": "CREATE OR REPLACE FUNCTION public.manage_task(p_task_id uuid DEFAULT NULL::uuid, p_project_id uuid DEFAULT NULL::uuid, p_name text DEFAULT NULL::text, p_description text DEFAULT NULL::text, p_assignee_id uuid DEFAULT NULL::uuid, p_status_id uuid DEFAULT NULL::uuid, p_priority task_priority DEFAULT 'Média'::task_priority, p_progress integer DEFAULT 0, p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date, p_parent_id uuid DEFAULT NULL::uuid, p_is_milestone boolean DEFAULT false, p_custom_fields jsonb DEFAULT '{}'::jsonb, p_tag_ids uuid[] DEFAULT '{}'::uuid[], p_dependency_ids uuid[] DEFAULT '{}'::uuid[], p_justification text DEFAULT NULL::text, p_propagate_dates boolean DEFAULT false)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_task_id uuid;\r\n    v_old_task public.tasks;\r\n    v_new_task public.tasks;\r\n    v_current_user_id uuid := auth.uid();\r\n    v_profile public.profiles;\r\n    v_notification_message text;\r\n    v_old_status_name text;\r\n    v_new_status_name text;\r\n    -- URL da sua função de edge para notificação. Ajuste se necessário.\r\n    v_function_url text := 'http://localhost:54321/functions/v1/send-task-notification';\r\n    -- **SUBSTITUA PELA SUA CHAVE DE SERVIÇO SUPABASE REAL**\r\n    v_service_role_key text := 'YOUR_SUPABASE_SERVICE_ROLE_KEY';\r\nBEGIN\r\n    -- Validação: Garante que um ID de projeto válido foi fornecido.\r\n    IF p_project_id IS NULL THEN\r\n        RAISE EXCEPTION 'ID do projeto não pode ser NULO';\r\n    END IF;\r\n\r\n    -- Validação de permissão: Verifica se o usuário atual é membro do projeto.\r\n    IF NOT is_project_member(p_project_id, v_current_user_id) THEN\r\n        RAISE EXCEPTION 'O utilizador não tem permissão para gerir tarefas neste projeto';\r\n    END IF;\r\n\r\n    -- Captura o estado antigo da tarefa para comparação, se um ID de tarefa foi fornecido (atualização).\r\n    IF p_task_id IS NOT NULL THEN\r\n        SELECT * INTO v_old_task FROM public.tasks WHERE id = p_task_id;\r\n    END IF;\r\n\r\n    -- Lógica Principal: Inserir uma nova tarefa ou Atualizar uma tarefa existente.\r\n    IF p_task_id IS NULL THEN\r\n        -- Inserir uma nova tarefa.\r\n        INSERT INTO public.tasks (project_id, name, description, assignee_id, status_id, priority, progress, start_date, end_date, parent_id, is_milestone, custom_fields)\r\n        VALUES (p_project_id, p_name, p_description, p_assignee_id, p_status_id, p_priority::task_priority, p_progress, p_start_date::date, p_end_date::date, p_parent_id, p_is_milestone, p_custom_fields)\r\n        RETURNING id INTO v_task_id; -- Obtém o ID da tarefa recém-inserida.\r\n    ELSE\r\n        -- Atualizar uma tarefa existente.\r\n        UPDATE public.tasks\r\n        SET\r\n            name = p_name, description = p_description, assignee_id = p_assignee_id,\r\n            status_id = p_status_id, priority = p_priority::task_priority, progress = p_progress,\r\n            start_date = p_start_date::date, end_date = p_end_date::date, parent_id = p_parent_id,\r\n            is_milestone = p_is_milestone, custom_fields = p_custom_fields, updated_at = now()\r\n        WHERE id = p_task_id\r\n        RETURNING id INTO v_task_id; -- Obtém o ID da tarefa que foi atualizada.\r\n\r\n        -- *** LÓGICA PARA DELETAR DEPENDÊNCIAS EXISTENTES ***\r\n        -- Remove todas as entradas na tabela task_dependencies para a tarefa atual.\r\n        -- Isso é feito antes de inserir as novas dependências para lidar com remoções.\r\n        DELETE FROM public.task_dependencies WHERE task_id = v_task_id;\r\n\r\n    END IF;\r\n\r\n    -- *** LÓGICA PARA INSERIR NOVAS DEPENDÊNCIAS ***\r\n    -- Verifica se o array p_dependency_ids não é nulo e se contém IDs antes de tentar inserir.\r\n    IF p_dependency_ids IS NOT NULL AND array_length(p_dependency_ids, 1) > 0 THEN\r\n        -- Insere as novas dependências na tabela task_dependencies.\r\n        -- unnest(p_dependency_ids) expande o array em linhas separadas.\r\n        INSERT INTO public.task_dependencies (task_id, dependency_id)\r\n        SELECT v_task_id, unnest(p_dependency_ids);\r\n    END IF;\r\n\r\n\r\n    -- Obtém o estado atualizado da tarefa após inserir/atualizar.\r\n    SELECT * INTO v_new_task FROM public.tasks WHERE id = v_task_id;\r\n\r\n    -- Lógica de notificação: Envia notificação se o status da tarefa mudou e houver um responsável.\r\n    IF v_old_task.id IS NOT NULL AND v_old_task.status_id IS DISTINCT FROM v_new_task.status_id AND v_new_task.assignee_id IS NOT NULL THEN\r\n        SELECT * INTO v_profile FROM public.profiles WHERE id = v_new_task.assignee_id;\r\n\r\n        IF v_profile.notifications_whatsapp = true AND v_profile.phone_number IS NOT NULL THEN\r\n            SELECT name INTO v_old_status_name FROM public.task_statuses WHERE id = v_old_task.status_id;\r\n            SELECT name INTO v_new_status_name FROM public.task_statuses WHERE id = v_new_task.status_id;\r\n\r\n            -- Monta a mensagem de notificação.\r\n            v_notification_message := 'Olá ' || v_profile.name || '! A tarefa \"' || v_new_task.name || '\" foi atualizada de \"' || v_old_status_name || '\" para \"' || v_new_status_name || '\".';\r\n\r\n            -- Chama a função de edge para enviar a notificação HTTP POST.\r\n            PERFORM net.http_post(\r\n                url := v_function_url,\r\n                headers := jsonb_build_object(\r\n                    'Content-Type', 'application/json',\r\n                    'Authorization', 'Bearer ' || v_service_role_key\r\n                ),\r\n                body := jsonb_build_object('to', v_profile.phone_number, 'body', v_notification_message)\r\n            );\r\n        END IF;\r\n    END IF;\r\n\r\n    -- Lógica de histórico e propagação de datas (espaço reservado)\r\n    -- Este é um espaço para adicionar lógica relacionada ao histórico de mudanças da tarefa\r\n    -- ou para propagar mudanças de data para tarefas dependentes, se necessário.\r\n    -- ...\r\n\r\n    -- Retorna o ID da tarefa inserida ou atualizada.\r\n    RETURN v_task_id;\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "objects_insert_prefix_trigger",
    "definicao": "CREATE OR REPLACE FUNCTION storage.objects_insert_prefix_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    PERFORM \"storage\".\"add_prefixes\"(NEW.\"bucket_id\", NEW.\"name\");\n    NEW.level := \"storage\".\"get_level\"(NEW.\"name\");\n\n    RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "nome_funcao": "objects_update_prefix_trigger",
    "definicao": "CREATE OR REPLACE FUNCTION storage.objects_update_prefix_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    old_prefixes TEXT[];\nBEGIN\n    -- Ensure this is an update operation and the name has changed\n    IF TG_OP = 'UPDATE' AND (NEW.\"name\" <> OLD.\"name\" OR NEW.\"bucket_id\" <> OLD.\"bucket_id\") THEN\n        -- Retrieve old prefixes\n        old_prefixes := \"storage\".\"get_prefixes\"(OLD.\"name\");\n\n        -- Remove old prefixes that are only used by this object\n        WITH all_prefixes as (\n            SELECT unnest(old_prefixes) as prefix\n        ),\n        can_delete_prefixes as (\n             SELECT prefix\n             FROM all_prefixes\n             WHERE NOT EXISTS (\n                 SELECT 1 FROM \"storage\".\"objects\"\n                 WHERE \"bucket_id\" = OLD.\"bucket_id\"\n                   AND \"name\" <> OLD.\"name\"\n                   AND \"name\" LIKE (prefix || '%')\n             )\n         )\n        DELETE FROM \"storage\".\"prefixes\" WHERE name IN (SELECT prefix FROM can_delete_prefixes);\n\n        -- Add new prefixes\n        PERFORM \"storage\".\"add_prefixes\"(NEW.\"bucket_id\", NEW.\"name\");\n    END IF;\n    -- Set the new level\n    NEW.\"level\" := \"storage\".\"get_level\"(NEW.\"name\");\n\n    RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "nome_funcao": "operation",
    "definicao": "CREATE OR REPLACE FUNCTION storage.operation()\n RETURNS text\n LANGUAGE plpgsql\n STABLE\nAS $function$\nBEGIN\n    RETURN current_setting('storage.operation', true);\nEND;\n$function$\n"
  },
  {
    "nome_funcao": "pg_stat_statements",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.pg_stat_statements(showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT shared_blk_read_time double precision, OUT shared_blk_write_time double precision, OUT local_blk_read_time double precision, OUT local_blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision, OUT jit_deform_count bigint, OUT jit_deform_time double precision, OUT stats_since timestamp with time zone, OUT minmax_stats_since timestamp with time zone)\n RETURNS SETOF record\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pg_stat_statements', $function$pg_stat_statements_1_11$function$\n"
  },
  {
    "nome_funcao": "pg_stat_statements_info",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.pg_stat_statements_info(OUT dealloc bigint, OUT stats_reset timestamp with time zone)\n RETURNS record\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pg_stat_statements', $function$pg_stat_statements_info$function$\n"
  },
  {
    "nome_funcao": "pg_stat_statements_reset",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.pg_stat_statements_reset(userid oid DEFAULT 0, dbid oid DEFAULT 0, queryid bigint DEFAULT 0, minmax_only boolean DEFAULT false)\n RETURNS timestamp with time zone\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pg_stat_statements', $function$pg_stat_statements_reset_1_11$function$\n"
  },
  {
    "nome_funcao": "pgp_armor_headers",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.pgp_armor_headers(text, OUT key text, OUT value text)\n RETURNS SETOF record\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_armor_headers$function$\n"
  },
  {
    "nome_funcao": "pgp_key_id",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.pgp_key_id(bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_key_id_w$function$\n"
  },
  {
    "nome_funcao": "pgp_pub_decrypt",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n"
  },
  {
    "nome_funcao": "pgp_pub_decrypt",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n"
  },
  {
    "nome_funcao": "pgp_pub_decrypt",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n"
  },
  {
    "nome_funcao": "pgp_pub_decrypt_bytea",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n"
  },
  {
    "nome_funcao": "pgp_pub_decrypt_bytea",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n"
  },
  {
    "nome_funcao": "pgp_pub_decrypt_bytea",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n"
  },
  {
    "nome_funcao": "pgp_pub_encrypt",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt(text, bytea)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$\n"
  },
  {
    "nome_funcao": "pgp_pub_encrypt",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt(text, bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$\n"
  },
  {
    "nome_funcao": "pgp_pub_encrypt_bytea",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$\n"
  },
  {
    "nome_funcao": "pgp_pub_encrypt_bytea",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$\n"
  },
  {
    "nome_funcao": "pgp_sym_decrypt",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt(bytea, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$\n"
  },
  {
    "nome_funcao": "pgp_sym_decrypt",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt(bytea, text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$\n"
  },
  {
    "nome_funcao": "pgp_sym_decrypt_bytea",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$\n"
  },
  {
    "nome_funcao": "pgp_sym_decrypt_bytea",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$\n"
  },
  {
    "nome_funcao": "pgp_sym_encrypt",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt(text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$\n"
  },
  {
    "nome_funcao": "pgp_sym_encrypt",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt(text, text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$\n"
  },
  {
    "nome_funcao": "pgp_sym_encrypt_bytea",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$\n"
  },
  {
    "nome_funcao": "pgp_sym_encrypt_bytea",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$\n"
  },
  {
    "nome_funcao": "pgrst_ddl_watch",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.pgrst_ddl_watch()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  cmd record;\nBEGIN\n  FOR cmd IN SELECT * FROM pg_event_trigger_ddl_commands()\n  LOOP\n    IF cmd.command_tag IN (\n      'CREATE SCHEMA', 'ALTER SCHEMA'\n    , 'CREATE TABLE', 'CREATE TABLE AS', 'SELECT INTO', 'ALTER TABLE'\n    , 'CREATE FOREIGN TABLE', 'ALTER FOREIGN TABLE'\n    , 'CREATE VIEW', 'ALTER VIEW'\n    , 'CREATE MATERIALIZED VIEW', 'ALTER MATERIALIZED VIEW'\n    , 'CREATE FUNCTION', 'ALTER FUNCTION'\n    , 'CREATE TRIGGER'\n    , 'CREATE TYPE', 'ALTER TYPE'\n    , 'CREATE RULE'\n    , 'COMMENT'\n    )\n    -- don't notify in case of CREATE TEMP table or other objects created on pg_temp\n    AND cmd.schema_name is distinct from 'pg_temp'\n    THEN\n      NOTIFY pgrst, 'reload schema';\n    END IF;\n  END LOOP;\nEND; $function$\n"
  },
  {
    "nome_funcao": "pgrst_drop_watch",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.pgrst_drop_watch()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  obj record;\nBEGIN\n  FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()\n  LOOP\n    IF obj.object_type IN (\n      'schema'\n    , 'table'\n    , 'foreign table'\n    , 'view'\n    , 'materialized view'\n    , 'function'\n    , 'trigger'\n    , 'type'\n    , 'rule'\n    )\n    AND obj.is_temporary IS false -- no pg_temp objects\n    THEN\n      NOTIFY pgrst, 'reload schema';\n    END IF;\n  END LOOP;\nEND; $function$\n"
  },
  {
    "nome_funcao": "prefixes_insert_trigger",
    "definicao": "CREATE OR REPLACE FUNCTION storage.prefixes_insert_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    PERFORM \"storage\".\"add_prefixes\"(NEW.\"bucket_id\", NEW.\"name\");\n    RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "nome_funcao": "quote_wal2json",
    "definicao": "CREATE OR REPLACE FUNCTION realtime.quote_wal2json(entity regclass)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$\n      select\n        (\n          select string_agg('' || ch,'')\n          from unnest(string_to_array(nsp.nspname::text, null)) with ordinality x(ch, idx)\n          where\n            not (x.idx = 1 and x.ch = '\"')\n            and not (\n              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)\n              and x.ch = '\"'\n            )\n        )\n        || '.'\n        || (\n          select string_agg('' || ch,'')\n          from unnest(string_to_array(pc.relname::text, null)) with ordinality x(ch, idx)\n          where\n            not (x.idx = 1 and x.ch = '\"')\n            and not (\n              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)\n              and x.ch = '\"'\n            )\n          )\n      from\n        pg_class pc\n        join pg_namespace nsp\n          on pc.relnamespace = nsp.oid\n      where\n        pc.oid = entity\n    $function$\n"
  },
  {
    "nome_funcao": "record_project_progress",
    "definicao": "CREATE OR REPLACE FUNCTION public.record_project_progress(p_project_id uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_budget numeric;\r\n    v_start date;\r\n    v_end date;\r\n    v_total_days integer;\r\n    v_elapsed_days integer;\r\n    v_total_tasks integer;\r\n    v_completed_tasks integer;\r\n    v_sum_progress numeric;\r\n    v_planned_value numeric;\r\n    v_earned_value numeric;\r\n    v_actual_cost numeric;\r\nBEGIN\r\n    SELECT budget, start_date, end_date\r\n    INTO v_budget, v_start, v_end\r\n    FROM public.projects\r\n    WHERE id = p_project_id;\r\n\r\n    IF v_budget IS NULL THEN\r\n        RETURN;\r\n    END IF;\r\n\r\n    v_total_days := GREATEST((v_end - v_start), 1);\r\n    v_elapsed_days := GREATEST((CURRENT_DATE - v_start), 0);\r\n    v_planned_value := v_budget * LEAST(v_elapsed_days, v_total_days) / v_total_days;\r\n\r\n    SELECT COUNT(*),\r\n           COUNT(*) FILTER (WHERE status_id = (SELECT id FROM public.task_statuses WHERE name = 'Concluído')),\r\n           COALESCE(SUM(progress), 0)\r\n    INTO v_total_tasks, v_completed_tasks, v_sum_progress\r\n    FROM public.tasks\r\n    WHERE project_id = p_project_id;\r\n\r\n    IF v_total_tasks = 0 THEN\r\n        v_earned_value := 0;\r\n        v_actual_cost := 0;\r\n    ELSE\r\n        v_earned_value := v_budget * v_completed_tasks / v_total_tasks;\r\n        v_actual_cost := v_budget * v_sum_progress / (100 * v_total_tasks);\r\n    END IF;\r\n\r\n    INSERT INTO public.project_progress (project_id, date, planned_value, earned_value, actual_cost)\r\n    VALUES (p_project_id, CURRENT_DATE, v_planned_value, v_earned_value, v_actual_cost)\r\n    ON CONFLICT (project_id, date) DO UPDATE\r\n      SET planned_value = EXCLUDED.planned_value,\r\n          earned_value = EXCLUDED.earned_value,\r\n          actual_cost = EXCLUDED.actual_cost;\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "record_project_progress_from_project",
    "definicao": "CREATE OR REPLACE FUNCTION public.record_project_progress_from_project()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    PERFORM public.record_project_progress(NEW.id);\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "record_project_progress_from_task",
    "definicao": "CREATE OR REPLACE FUNCTION public.record_project_progress_from_task()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    PERFORM public.record_project_progress(COALESCE(NEW.project_id, OLD.project_id));\r\n    RETURN NULL;\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "resolve",
    "definicao": "CREATE OR REPLACE FUNCTION graphql.resolve(query text, variables jsonb DEFAULT '{}'::jsonb, \"operationName\" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\ndeclare\n    res jsonb;\n    message_text text;\nbegin\n  begin\n    select graphql._internal_resolve(\"query\" := \"query\",\n                                     \"variables\" := \"variables\",\n                                     \"operationName\" := \"operationName\",\n                                     \"extensions\" := \"extensions\") into res;\n    return res;\n  exception\n    when others then\n    get stacked diagnostics message_text = message_text;\n    return\n    jsonb_build_object('data', null,\n                       'errors', jsonb_build_array(jsonb_build_object('message', message_text)));\n  end;\nend;\n$function$\n"
  },
  {
    "nome_funcao": "role",
    "definicao": "CREATE OR REPLACE FUNCTION auth.role()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.role', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role')\n  )::text\n$function$\n"
  },
  {
    "nome_funcao": "search",
    "definicao": "CREATE OR REPLACE FUNCTION storage.search(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)\n RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\nAS $function$\ndeclare\n    can_bypass_rls BOOLEAN;\nbegin\n    SELECT rolbypassrls\n    INTO can_bypass_rls\n    FROM pg_roles\n    WHERE rolname = coalesce(nullif(current_setting('role', true), 'none'), current_user);\n\n    IF can_bypass_rls THEN\n        RETURN QUERY SELECT * FROM storage.search_v1_optimised(prefix, bucketname, limits, levels, offsets, search, sortcolumn, sortorder);\n    ELSE\n        RETURN QUERY SELECT * FROM storage.search_legacy_v1(prefix, bucketname, limits, levels, offsets, search, sortcolumn, sortorder);\n    END IF;\nend;\n$function$\n"
  },
  {
    "nome_funcao": "search_legacy_v1",
    "definicao": "CREATE OR REPLACE FUNCTION storage.search_legacy_v1(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)\n RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\ndeclare\n    v_order_by text;\n    v_sort_order text;\nbegin\n    case\n        when sortcolumn = 'name' then\n            v_order_by = 'name';\n        when sortcolumn = 'updated_at' then\n            v_order_by = 'updated_at';\n        when sortcolumn = 'created_at' then\n            v_order_by = 'created_at';\n        when sortcolumn = 'last_accessed_at' then\n            v_order_by = 'last_accessed_at';\n        else\n            v_order_by = 'name';\n        end case;\n\n    case\n        when sortorder = 'asc' then\n            v_sort_order = 'asc';\n        when sortorder = 'desc' then\n            v_sort_order = 'desc';\n        else\n            v_sort_order = 'asc';\n        end case;\n\n    v_order_by = v_order_by || ' ' || v_sort_order;\n\n    return query execute\n        'with folders as (\n           select path_tokens[$1] as folder\n           from storage.objects\n             where objects.name ilike $2 || $3 || ''%''\n               and bucket_id = $4\n               and array_length(objects.path_tokens, 1) <> $1\n           group by folder\n           order by folder ' || v_sort_order || '\n     )\n     (select folder as \"name\",\n            null as id,\n            null as updated_at,\n            null as created_at,\n            null as last_accessed_at,\n            null as metadata from folders)\n     union all\n     (select path_tokens[$1] as \"name\",\n            id,\n            updated_at,\n            created_at,\n            last_accessed_at,\n            metadata\n     from storage.objects\n     where objects.name ilike $2 || $3 || ''%''\n       and bucket_id = $4\n       and array_length(objects.path_tokens, 1) = $1\n     order by ' || v_order_by || ')\n     limit $5\n     offset $6' using levels, prefix, search, bucketname, limits, offsets;\nend;\n$function$\n"
  },
  {
    "nome_funcao": "search_v1_optimised",
    "definicao": "CREATE OR REPLACE FUNCTION storage.search_v1_optimised(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)\n RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\ndeclare\n    v_order_by text;\n    v_sort_order text;\nbegin\n    case\n        when sortcolumn = 'name' then\n            v_order_by = 'name';\n        when sortcolumn = 'updated_at' then\n            v_order_by = 'updated_at';\n        when sortcolumn = 'created_at' then\n            v_order_by = 'created_at';\n        when sortcolumn = 'last_accessed_at' then\n            v_order_by = 'last_accessed_at';\n        else\n            v_order_by = 'name';\n        end case;\n\n    case\n        when sortorder = 'asc' then\n            v_sort_order = 'asc';\n        when sortorder = 'desc' then\n            v_sort_order = 'desc';\n        else\n            v_sort_order = 'asc';\n        end case;\n\n    v_order_by = v_order_by || ' ' || v_sort_order;\n\n    return query execute\n        'with folders as (\n           select (string_to_array(name, ''/''))[level] as name\n           from storage.prefixes\n             where lower(prefixes.name) like lower($2 || $3) || ''%''\n               and bucket_id = $4\n               and level = $1\n           order by name ' || v_sort_order || '\n     )\n     (select name,\n            null as id,\n            null as updated_at,\n            null as created_at,\n            null as last_accessed_at,\n            null as metadata from folders)\n     union all\n     (select path_tokens[level] as \"name\",\n            id,\n            updated_at,\n            created_at,\n            last_accessed_at,\n            metadata\n     from storage.objects\n     where lower(objects.name) like lower($2 || $3) || ''%''\n       and bucket_id = $4\n       and level = $1\n     order by ' || v_order_by || ')\n     limit $5\n     offset $6' using levels, prefix, search, bucketname, limits, offsets;\nend;\n$function$\n"
  },
  {
    "nome_funcao": "search_v2",
    "definicao": "CREATE OR REPLACE FUNCTION storage.search_v2(prefix text, bucket_name text, limits integer DEFAULT 100, levels integer DEFAULT 1, start_after text DEFAULT ''::text)\n RETURNS TABLE(key text, name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\nBEGIN\n    RETURN query EXECUTE\n        $sql$\n        SELECT * FROM (\n            (\n                SELECT\n                    split_part(name, '/', $4) AS key,\n                    name || '/' AS name,\n                    NULL::uuid AS id,\n                    NULL::timestamptz AS updated_at,\n                    NULL::timestamptz AS created_at,\n                    NULL::jsonb AS metadata\n                FROM storage.prefixes\n                WHERE name COLLATE \"C\" LIKE $1 || '%'\n                AND bucket_id = $2\n                AND level = $4\n                AND name COLLATE \"C\" > $5\n                ORDER BY prefixes.name COLLATE \"C\" LIMIT $3\n            )\n            UNION ALL\n            (SELECT split_part(name, '/', $4) AS key,\n                name,\n                id,\n                updated_at,\n                created_at,\n                metadata\n            FROM storage.objects\n            WHERE name COLLATE \"C\" LIKE $1 || '%'\n                AND bucket_id = $2\n                AND level = $4\n                AND name COLLATE \"C\" > $5\n            ORDER BY name COLLATE \"C\" LIMIT $3)\n        ) obj\n        ORDER BY name COLLATE \"C\" LIMIT $3;\n        $sql$\n        USING prefix, bucket_name, limits, levels, start_after;\nEND;\n$function$\n"
  },
  {
    "nome_funcao": "send",
    "definicao": "CREATE OR REPLACE FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean DEFAULT true)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  BEGIN\n    -- Set the topic configuration\n    EXECUTE format('SET LOCAL realtime.topic TO %L', topic);\n\n    -- Attempt to insert the message\n    INSERT INTO realtime.messages (payload, event, topic, private, extension)\n    VALUES (payload, event, topic, private, 'broadcast');\n  EXCEPTION\n    WHEN OTHERS THEN\n      -- Capture and notify the error\n      RAISE WARNING 'ErrorSendingBroadcastMessage: %', SQLERRM;\n  END;\nEND;\n$function$\n"
  },
  {
    "nome_funcao": "set_graphql_placeholder",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.set_graphql_placeholder()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\n    DECLARE\n    graphql_is_dropped bool;\n    BEGIN\n    graphql_is_dropped = (\n        SELECT ev.schema_name = 'graphql_public'\n        FROM pg_event_trigger_dropped_objects() AS ev\n        WHERE ev.schema_name = 'graphql_public'\n    );\n\n    IF graphql_is_dropped\n    THEN\n        create or replace function graphql_public.graphql(\n            \"operationName\" text default null,\n            query text default null,\n            variables jsonb default null,\n            extensions jsonb default null\n        )\n            returns jsonb\n            language plpgsql\n        as $$\n            DECLARE\n                server_version float;\n            BEGIN\n                server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);\n\n                IF server_version >= 14 THEN\n                    RETURN jsonb_build_object(\n                        'errors', jsonb_build_array(\n                            jsonb_build_object(\n                                'message', 'pg_graphql extension is not enabled.'\n                            )\n                        )\n                    );\n                ELSE\n                    RETURN jsonb_build_object(\n                        'errors', jsonb_build_array(\n                            jsonb_build_object(\n                                'message', 'pg_graphql is only available on projects running Postgres 14 onwards.'\n                            )\n                        )\n                    );\n                END IF;\n            END;\n        $$;\n    END IF;\n\n    END;\n$function$\n"
  },
  {
    "nome_funcao": "subscription_check_filters",
    "definicao": "CREATE OR REPLACE FUNCTION realtime.subscription_check_filters()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\n    /*\n    Validates that the user defined filters for a subscription:\n    - refer to valid columns that the claimed role may access\n    - values are coercable to the correct column type\n    */\n    declare\n        col_names text[] = coalesce(\n                array_agg(c.column_name order by c.ordinal_position),\n                '{}'::text[]\n            )\n            from\n                information_schema.columns c\n            where\n                format('%I.%I', c.table_schema, c.table_name)::regclass = new.entity\n                and pg_catalog.has_column_privilege(\n                    (new.claims ->> 'role'),\n                    format('%I.%I', c.table_schema, c.table_name)::regclass,\n                    c.column_name,\n                    'SELECT'\n                );\n        filter realtime.user_defined_filter;\n        col_type regtype;\n\n        in_val jsonb;\n    begin\n        for filter in select * from unnest(new.filters) loop\n            -- Filtered column is valid\n            if not filter.column_name = any(col_names) then\n                raise exception 'invalid column for filter %', filter.column_name;\n            end if;\n\n            -- Type is sanitized and safe for string interpolation\n            col_type = (\n                select atttypid::regtype\n                from pg_catalog.pg_attribute\n                where attrelid = new.entity\n                      and attname = filter.column_name\n            );\n            if col_type is null then\n                raise exception 'failed to lookup type for column %', filter.column_name;\n            end if;\n\n            -- Set maximum number of entries for in filter\n            if filter.op = 'in'::realtime.equality_op then\n                in_val = realtime.cast(filter.value, (col_type::text || '[]')::regtype);\n                if coalesce(jsonb_array_length(in_val), 0) > 100 then\n                    raise exception 'too many values for `in` filter. Maximum 100';\n                end if;\n            else\n                -- raises an exception if value is not coercable to type\n                perform realtime.cast(filter.value, col_type);\n            end if;\n\n        end loop;\n\n        -- Apply consistent order to filters so the unique constraint on\n        -- (subscription_id, entity, filters) can't be tricked by a different filter order\n        new.filters = coalesce(\n            array_agg(f order by f.column_name, f.op, f.value),\n            '{}'\n        ) from unnest(new.filters) f;\n\n        return new;\n    end;\n    $function$\n"
  },
  {
    "nome_funcao": "text_to_bytea",
    "definicao": "CREATE OR REPLACE FUNCTION public.text_to_bytea(data text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE STRICT\nAS '$libdir/http', $function$text_to_bytea$function$\n"
  },
  {
    "nome_funcao": "to_regrole",
    "definicao": "CREATE OR REPLACE FUNCTION realtime.to_regrole(role_name text)\n RETURNS regrole\n LANGUAGE sql\n IMMUTABLE\nAS $function$ select role_name::regrole $function$\n"
  },
  {
    "nome_funcao": "topic",
    "definicao": "CREATE OR REPLACE FUNCTION realtime.topic()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\nselect nullif(current_setting('realtime.topic', true), '')::text;\n$function$\n"
  },
  {
    "nome_funcao": "uid",
    "definicao": "CREATE OR REPLACE FUNCTION auth.uid()\n RETURNS uuid\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.sub', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'sub')\n  )::uuid\n$function$\n"
  },
  {
    "nome_funcao": "update_secret",
    "definicao": "CREATE OR REPLACE FUNCTION vault.update_secret(secret_id uuid, new_secret text DEFAULT NULL::text, new_name text DEFAULT NULL::text, new_description text DEFAULT NULL::text, new_key_id uuid DEFAULT NULL::uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  decrypted_secret text := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE id = secret_id);\nBEGIN\n  UPDATE vault.secrets s\n  SET\n    secret = CASE WHEN new_secret IS NULL THEN s.secret\n                  ELSE encode(vault._crypto_aead_det_encrypt(\n                    message := convert_to(new_secret, 'utf8'),\n                    additional := convert_to(s.id::text, 'utf8'),\n                    key_id := 0,\n                    context := 'pgsodium'::bytea,\n                    nonce := s.nonce\n                  ), 'base64') END,\n    name = coalesce(new_name, s.name),\n    description = coalesce(new_description, s.description),\n    updated_at = now()\n  WHERE s.id = secret_id;\nEND\n$function$\n"
  },
  {
    "nome_funcao": "update_task_observation",
    "definicao": "CREATE OR REPLACE FUNCTION public.update_task_observation(p_observation_id uuid, p_new_content text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    UPDATE public.task_observations\r\n    SET content = p_new_content, updated_at = now()\r\n    WHERE id = p_observation_id AND author_id = auth.uid();\r\n\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Acesso não autorizado ou observação não encontrada.';\r\n    END IF;\r\nEND;\r\n$function$\n"
  },
  {
    "nome_funcao": "update_updated_at_column",
    "definicao": "CREATE OR REPLACE FUNCTION storage.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = now();\n    RETURN NEW; \nEND;\n$function$\n"
  },
  {
    "nome_funcao": "urlencode",
    "definicao": "CREATE OR REPLACE FUNCTION public.urlencode(string bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE STRICT\nAS '$libdir/http', $function$urlencode$function$\n"
  },
  {
    "nome_funcao": "urlencode",
    "definicao": "CREATE OR REPLACE FUNCTION public.urlencode(string character varying)\n RETURNS text\n LANGUAGE c\n IMMUTABLE STRICT\nAS '$libdir/http', $function$urlencode$function$\n"
  },
  {
    "nome_funcao": "urlencode",
    "definicao": "CREATE OR REPLACE FUNCTION public.urlencode(data jsonb)\n RETURNS text\n LANGUAGE c\n IMMUTABLE STRICT\nAS '$libdir/http', $function$urlencode_jsonb$function$\n"
  },
  {
    "nome_funcao": "uuid_generate_v1",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v1()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v1$function$\n"
  },
  {
    "nome_funcao": "uuid_generate_v1mc",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v1mc()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v1mc$function$\n"
  },
  {
    "nome_funcao": "uuid_generate_v3",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v3(namespace uuid, name text)\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v3$function$\n"
  },
  {
    "nome_funcao": "uuid_generate_v4",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v4()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v4$function$\n"
  },
  {
    "nome_funcao": "uuid_generate_v5",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v5(namespace uuid, name text)\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v5$function$\n"
  },
  {
    "nome_funcao": "uuid_nil",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.uuid_nil()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_nil$function$\n"
  },
  {
    "nome_funcao": "uuid_ns_dns",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_dns()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_dns$function$\n"
  },
  {
    "nome_funcao": "uuid_ns_oid",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_oid()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_oid$function$\n"
  },
  {
    "nome_funcao": "uuid_ns_url",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_url()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_url$function$\n"
  },
  {
    "nome_funcao": "uuid_ns_x500",
    "definicao": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_x500()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_x500$function$\n"
  },
  {
    "nome_funcao": "worker_restart",
    "definicao": "CREATE OR REPLACE FUNCTION net.worker_restart()\n RETURNS boolean\n LANGUAGE c\nAS 'pg_net', $function$worker_restart$function$\n"
  }
]
